(function () {
/**
 * almond 0.2.6 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("almond", function(){});

(function() {
var define, requireModule, require, requirejs;

(function() {
  var registry = {}, seen = {};

  define = function(name, deps, callback) {
    registry[name] = { deps: deps, callback: callback };
  };

  requirejs = require = requireModule = function(name) {
  requirejs._eak_seen = registry;

    if (seen[name]) { return seen[name]; }
    seen[name] = {};

    if (!registry[name]) {
      throw new Error("Could not find module " + name);
    }

    var mod = registry[name],
        deps = mod.deps,
        callback = mod.callback,
        reified = [],
        exports;

    for (var i=0, l=deps.length; i<l; i++) {
      if (deps[i] === 'exports') {
        reified.push(exports = {});
      } else {
        reified.push(requireModule(resolve(deps[i])));
      }
    }

    var value = callback.apply(this, reified);
    return seen[name] = exports || value;

    function resolve(child) {
      if (child.charAt(0) !== '.') { return child; }
      var parts = child.split("/");
      var parentBase = name.split("/").slice(0, -1);

      for (var i=0, l=parts.length; i<l; i++) {
        var part = parts[i];

        if (part === '..') { parentBase.pop(); }
        else if (part === '.') { continue; }
        else { parentBase.push(part); }
      }

      return parentBase.join("/");
    }
  };
})();

define("promise/all", 
  ["./utils","exports"],
  function(__dependency1__, __exports__) {
    
    /* global toString */

    var isArray = __dependency1__.isArray;
    var isFunction = __dependency1__.isFunction;

    /**
      Returns a promise that is fulfilled when all the given promises have been
      fulfilled, or rejected if any of them become rejected. The return promise
      is fulfilled with an array that gives all the values in the order they were
      passed in the `promises` array argument.

      Example:

      ```javascript
      var promise1 = RSVP.resolve(1);
      var promise2 = RSVP.resolve(2);
      var promise3 = RSVP.resolve(3);
      var promises = [ promise1, promise2, promise3 ];

      RSVP.all(promises).then(function(array){
        // The array here would be [ 1, 2, 3 ];
      });
      ```

      If any of the `promises` given to `RSVP.all` are rejected, the first promise
      that is rejected will be given as an argument to the returned promises's
      rejection handler. For example:

      Example:

      ```javascript
      var promise1 = RSVP.resolve(1);
      var promise2 = RSVP.reject(new Error("2"));
      var promise3 = RSVP.reject(new Error("3"));
      var promises = [ promise1, promise2, promise3 ];

      RSVP.all(promises).then(function(array){
        // Code here never runs because there are rejected promises!
      }, function(error) {
        // error.message === "2"
      });
      ```

      @method all
      @for RSVP
      @param {Array} promises
      @param {String} label
      @return {Promise} promise that is fulfilled when all `promises` have been
      fulfilled, or rejected if any of them become rejected.
    */
    function all(promises) {
      /*jshint validthis:true */
      var Promise = this;

      if (!isArray(promises)) {
        throw new TypeError('You must pass an array to all.');
      }

      return new Promise(function(resolve, reject) {
        var results = [], remaining = promises.length,
        promise;

        if (remaining === 0) {
          resolve([]);
        }

        function resolver(index) {
          return function(value) {
            resolveAll(index, value);
          };
        }

        function resolveAll(index, value) {
          results[index] = value;
          if (--remaining === 0) {
            resolve(results);
          }
        }

        for (var i = 0; i < promises.length; i++) {
          promise = promises[i];

          if (promise && isFunction(promise.then)) {
            promise.then(resolver(i), reject);
          } else {
            resolveAll(i, promise);
          }
        }
      });
    }

    __exports__.all = all;
  });
define("promise/asap", 
  ["exports"],
  function(__exports__) {
    
    var browserGlobal = (typeof window !== 'undefined') ? window : {};
    var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
    var local = (typeof global !== 'undefined') ? global : this;

    // node
    function useNextTick() {
      return function() {
        process.nextTick(flush);
      };
    }

    function useMutationObserver() {
      var iterations = 0;
      var observer = new BrowserMutationObserver(flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    function useSetTimeout() {
      return function() {
        local.setTimeout(flush, 1);
      };
    }

    var queue = [];
    function flush() {
      for (var i = 0; i < queue.length; i++) {
        var tuple = queue[i];
        var callback = tuple[0], arg = tuple[1];
        callback(arg);
      }
      queue = [];
    }

    var scheduleFlush;

    // Decide what async method to use to triggering processing of queued callbacks:
    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
      scheduleFlush = useNextTick();
    } else if (BrowserMutationObserver) {
      scheduleFlush = useMutationObserver();
    } else {
      scheduleFlush = useSetTimeout();
    }

    function asap(callback, arg) {
      var length = queue.push([callback, arg]);
      if (length === 1) {
        // If length is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        scheduleFlush();
      }
    }

    __exports__.asap = asap;
  });
define("promise/cast", 
  ["exports"],
  function(__exports__) {
    
    /**
      `RSVP.Promise.cast` returns the same promise if that promise shares a constructor
      with the promise being casted.

      Example:

      ```javascript
      var promise = RSVP.resolve(1);
      var casted = RSVP.Promise.cast(promise);

      console.log(promise === casted); // true
      ```

      In the case of a promise whose constructor does not match, it is assimilated.
      The resulting promise will fulfill or reject based on the outcome of the
      promise being casted.

      In the case of a non-promise, a promise which will fulfill with that value is
      returned.

      Example:

      ```javascript
      var value = 1; // could be a number, boolean, string, undefined...
      var casted = RSVP.Promise.cast(value);

      console.log(value === casted); // false
      console.log(casted instanceof RSVP.Promise) // true

      casted.then(function(val) {
        val === value // => true
      });
      ```

      `RSVP.Promise.cast` is similar to `RSVP.resolve`, but `RSVP.Promise.cast` differs in the
      following ways:
      * `RSVP.Promise.cast` serves as a memory-efficient way of getting a promise, when you
      have something that could either be a promise or a value. RSVP.resolve
      will have the same effect but will create a new promise wrapper if the
      argument is a promise.
      * `RSVP.Promise.cast` is a way of casting incoming thenables or promise subclasses to
      promises of the exact class specified, so that the resulting object's `then` is
      ensured to have the behavior of the constructor you are calling cast on (i.e., RSVP.Promise).

      @method cast
      @for RSVP
      @param {Object} object to be casted
      @return {Promise} promise that is fulfilled when all properties of `promises`
      have been fulfilled, or rejected if any of them become rejected.
    */


    function cast(object) {
      /*jshint validthis:true */
      if (object && typeof object === 'object' && object.constructor === this) {
        return object;
      }

      var Promise = this;

      return new Promise(function(resolve) {
        resolve(object);
      });
    }

    __exports__.cast = cast;
  });
define("promise/config", 
  ["exports"],
  function(__exports__) {
    
    var config = {
      instrument: false
    };

    function configure(name, value) {
      if (arguments.length === 2) {
        config[name] = value;
      } else {
        return config[name];
      }
    }

    __exports__.config = config;
    __exports__.configure = configure;
  });
define("promise/polyfill", 
  ["./promise","./utils","exports"],
  function(__dependency1__, __dependency2__, __exports__) {
    
    var RSVPPromise = __dependency1__.Promise;
    var isFunction = __dependency2__.isFunction;

    function polyfill() {
      var es6PromiseSupport = 
        "Promise" in window &&
        // Some of these methods are missing from
        // Firefox/Chrome experimental implementations
        "cast" in window.Promise &&
        "resolve" in window.Promise &&
        "reject" in window.Promise &&
        "all" in window.Promise &&
        "race" in window.Promise &&
        // Older version of the spec had a resolver object
        // as the arg rather than a function
        (function() {
          var resolve;
          new window.Promise(function(r) { resolve = r; });
          return isFunction(resolve);
        }());

      if (!es6PromiseSupport) {
        window.Promise = RSVPPromise;
      }
    }

    __exports__.polyfill = polyfill;
  });
define("promise/promise", 
  ["./config","./utils","./cast","./all","./race","./resolve","./reject","./asap","exports"],
  function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __dependency8__, __exports__) {
    
    var config = __dependency1__.config;
    var configure = __dependency1__.configure;
    var objectOrFunction = __dependency2__.objectOrFunction;
    var isFunction = __dependency2__.isFunction;
    var now = __dependency2__.now;
    var cast = __dependency3__.cast;
    var all = __dependency4__.all;
    var race = __dependency5__.race;
    var staticResolve = __dependency6__.resolve;
    var staticReject = __dependency7__.reject;
    var asap = __dependency8__.asap;

    var counter = 0;

    config.async = asap; // default async is asap;

    function Promise(resolver) {
      if (!isFunction(resolver)) {
        throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
      }

      if (!(this instanceof Promise)) {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }

      this._subscribers = [];

      invokeResolver(resolver, this);
    }

    function invokeResolver(resolver, promise) {
      function resolvePromise(value) {
        resolve(promise, value);
      }

      function rejectPromise(reason) {
        reject(promise, reason);
      }

      try {
        resolver(resolvePromise, rejectPromise);
      } catch(e) {
        rejectPromise(e);
      }
    }

    function invokeCallback(settled, promise, callback, detail) {
      var hasCallback = isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        try {
          value = callback(detail);
          succeeded = true;
        } catch(e) {
          failed = true;
          error = e;
        }
      } else {
        value = detail;
        succeeded = true;
      }

      if (handleThenable(promise, value)) {
        return;
      } else if (hasCallback && succeeded) {
        resolve(promise, value);
      } else if (failed) {
        reject(promise, error);
      } else if (settled === FULFILLED) {
        resolve(promise, value);
      } else if (settled === REJECTED) {
        reject(promise, value);
      }
    }

    var PENDING   = void 0;
    var SEALED    = 0;
    var FULFILLED = 1;
    var REJECTED  = 2;

    function subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      subscribers[length] = child;
      subscribers[length + FULFILLED] = onFulfillment;
      subscribers[length + REJECTED]  = onRejection;
    }

    function publish(promise, settled) {
      var child, callback, subscribers = promise._subscribers, detail = promise._detail;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        invokeCallback(settled, child, callback, detail);
      }

      promise._subscribers = null;
    }

    Promise.prototype = {
      constructor: Promise,

      _state: undefined,
      _detail: undefined,
      _subscribers: undefined,

      then: function(onFulfillment, onRejection) {
        var promise = this;

        var thenPromise = new this.constructor(function() {});

        if (this._state) {
          var callbacks = arguments;
          config.async(function invokePromiseCallback() {
            invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail);
          });
        } else {
          subscribe(this, thenPromise, onFulfillment, onRejection);
        }

        return thenPromise;
      },

      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };

    Promise.all = all;
    Promise.cast = cast;
    Promise.race = race;
    Promise.resolve = staticResolve;
    Promise.reject = staticReject;

    function handleThenable(promise, value) {
      var then = null,
      resolved;

      try {
        if (promise === value) {
          throw new TypeError("A promises callback cannot return that same promise.");
        }

        if (objectOrFunction(value)) {
          then = value.then;

          if (isFunction(then)) {
            then.call(value, function(val) {
              if (resolved) { return true; }
              resolved = true;

              if (value !== val) {
                resolve(promise, val);
              } else {
                fulfill(promise, val);
              }
            }, function(val) {
              if (resolved) { return true; }
              resolved = true;

              reject(promise, val);
            });

            return true;
          }
        }
      } catch (error) {
        if (resolved) { return true; }
        reject(promise, error);
        return true;
      }

      return false;
    }

    function resolve(promise, value) {
      if (promise === value) {
        fulfill(promise, value);
      } else if (!handleThenable(promise, value)) {
        fulfill(promise, value);
      }
    }

    function fulfill(promise, value) {
      if (promise._state !== PENDING) { return; }
      promise._state = SEALED;
      promise._detail = value;

      config.async(publishFulfillment, promise);
    }

    function reject(promise, reason) {
      if (promise._state !== PENDING) { return; }
      promise._state = SEALED;
      promise._detail = reason;

      config.async(publishRejection, promise);
    }

    function publishFulfillment(promise) {
      publish(promise, promise._state = FULFILLED);
    }

    function publishRejection(promise) {
      publish(promise, promise._state = REJECTED);
    }

    __exports__.Promise = Promise;
  });
define("promise/race", 
  ["./utils","exports"],
  function(__dependency1__, __exports__) {
    
    /* global toString */
    var isArray = __dependency1__.isArray;

    /**
      `RSVP.race` allows you to watch a series of promises and act as soon as the
      first promise given to the `promises` argument fulfills or rejects.

      Example:

      ```javascript
      var promise1 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          resolve("promise 1");
        }, 200);
      });

      var promise2 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          resolve("promise 2");
        }, 100);
      });

      RSVP.race([promise1, promise2]).then(function(result){
        // result === "promise 2" because it was resolved before promise1
        // was resolved.
      });
      ```

      `RSVP.race` is deterministic in that only the state of the first completed
      promise matters. For example, even if other promises given to the `promises`
      array argument are resolved, but the first completed promise has become
      rejected before the other promises became fulfilled, the returned promise
      will become rejected:

      ```javascript
      var promise1 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          resolve("promise 1");
        }, 200);
      });

      var promise2 = new RSVP.Promise(function(resolve, reject){
        setTimeout(function(){
          reject(new Error("promise 2"));
        }, 100);
      });

      RSVP.race([promise1, promise2]).then(function(result){
        // Code here never runs because there are rejected promises!
      }, function(reason){
        // reason.message === "promise2" because promise 2 became rejected before
        // promise 1 became fulfilled
      });
      ```

      @method race
      @for RSVP
      @param {Array} promises array of promises to observe
      @param {String} label optional string for describing the promise returned.
      Useful for tooling.
      @return {Promise} a promise that becomes fulfilled with the value the first
      completed promises is resolved with if the first completed promise was
      fulfilled, or rejected with the reason that the first completed promise
      was rejected with.
    */
    function race(promises) {
      /*jshint validthis:true */
      var Promise = this;

      if (!isArray(promises)) {
        throw new TypeError('You must pass an array to race.');
      }
      return new Promise(function(resolve, reject) {
        var results = [], promise;

        for (var i = 0; i < promises.length; i++) {
          promise = promises[i];

          if (promise && typeof promise.then === 'function') {
            promise.then(resolve, reject);
          } else {
            resolve(promise);
          }
        }
      });
    }

    __exports__.race = race;
  });
define("promise/reject", 
  ["exports"],
  function(__exports__) {
    
    /**
      `RSVP.reject` returns a promise that will become rejected with the passed
      `reason`. `RSVP.reject` is essentially shorthand for the following:

      ```javascript
      var promise = new RSVP.Promise(function(resolve, reject){
        reject(new Error('WHOOPS'));
      });

      promise.then(function(value){
        // Code here doesn't run because the promise is rejected!
      }, function(reason){
        // reason.message === 'WHOOPS'
      });
      ```

      Instead of writing the above, your code now simply becomes the following:

      ```javascript
      var promise = RSVP.reject(new Error('WHOOPS'));

      promise.then(function(value){
        // Code here doesn't run because the promise is rejected!
      }, function(reason){
        // reason.message === 'WHOOPS'
      });
      ```

      @method reject
      @for RSVP
      @param {Any} reason value that the returned promise will be rejected with.
      @param {String} label optional string for identifying the returned promise.
      Useful for tooling.
      @return {Promise} a promise that will become rejected with the given
      `reason`.
    */
    function reject(reason) {
      /*jshint validthis:true */
      var Promise = this;

      return new Promise(function (resolve, reject) {
        reject(reason);
      });
    }

    __exports__.reject = reject;
  });
define("promise/resolve", 
  ["exports"],
  function(__exports__) {
    
    /**
      `RSVP.resolve` returns a promise that will become fulfilled with the passed
      `value`. `RSVP.resolve` is essentially shorthand for the following:

      ```javascript
      var promise = new RSVP.Promise(function(resolve, reject){
        resolve(1);
      });

      promise.then(function(value){
        // value === 1
      });
      ```

      Instead of writing the above, your code now simply becomes the following:

      ```javascript
      var promise = RSVP.resolve(1);

      promise.then(function(value){
        // value === 1
      });
      ```

      @method resolve
      @for RSVP
      @param {Any} value value that the returned promise will be resolved with
      @param {String} label optional string for identifying the returned promise.
      Useful for tooling.
      @return {Promise} a promise that will become fulfilled with the given
      `value`
    */
    function resolve(value) {
      /*jshint validthis:true */
      var Promise = this;
      return new Promise(function(resolve, reject) {
        resolve(value);
      });
    }

    __exports__.resolve = resolve;
  });
define("promise/utils", 
  ["exports"],
  function(__exports__) {
    
    function objectOrFunction(x) {
      return isFunction(x) || (typeof x === "object" && x !== null);
    }

    function isFunction(x) {
      return typeof x === "function";
    }

    function isArray(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    }

    // Date.now is not available in browsers < IE9
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now#Compatibility
    var now = Date.now || function() { return new Date().getTime(); };


    __exports__.objectOrFunction = objectOrFunction;
    __exports__.isFunction = isFunction;
    __exports__.isArray = isArray;
    __exports__.now = now;
  });
requireModule('promise/polyfill').polyfill();
}());
define("promise", function(){});

define('event',[], function() {

  function Event() {
    this.init();
  }

  Event.prototype = {
    listeners: null,

    init: function() {
      this.listeners = [];
    },

    addListener: function(event, callback) {
      if (!this.listeners[event]) {
        this.listeners[event] = [];
      }

      this.listeners[event].push(callback);
    },

    removeListener: function(event, callback) {
      if (!this.listeners[event]) {
        return false;
      }

      var index = this.listeners[event].indexOf(callback);
      if (index !== -1) {
        delete this.listeners[event][index];
        return true;
      }

      return false;
    },

    trigger: function(event, data) {
      console.log("Triggering", event, data, this.listeners[event] ? this.listeners[event].length : 0, "listeners");

      if (!this.listeners[event]) {
        return false;
      }

      this.listeners[event].forEach(function(listener) {
        listener(data);
      });

      return true;
    }
  }

  return new Event();

});
define('globals',["event"], function(Event) {
  var Globals = function Globals() {
    this.init();
    window.g = this;
  };

  Globals.prototype = {
    init: function() {},

    isiOS: function() {
      return this.hasDeviceType("iOS");
    },

    isPC: function() {
      return this.hasDeviceType("PC");
    },

    isMac: function() {
      return this.hasDeviceType("Mac");
    },

    isComputer: function() {
      return this.hasDeviceType("computer");
    },

    isPhone: function() {
      return this.hasDeviceType("phone");
    },

    isTablet: function() {
      return this.hasDeviceType("tablet");
    },

    isMobile: function() {
      return this.isPhone() || this.isTablet();
    },

    hasDeviceType: function(type) {
      return this.getDeviceType().indexOf(type) !== -1;
    },

    getDeviceType: function() {
      if (localStorage.deviceType) {
        //return JSON.parse(localStorage.deviceType);
      }

      var devices = [];
      var userAgent = navigator.userAgent;

      if (userAgent.match(/iPad/g)) {
        devices.push("iOS");
        devices.push("iPad");
        devices.push("tablet");
      } else if (userAgent.match(/iPhone/g)) {
        devices.push("iOS");
        devices.push("iPhone");
        devices.push("phone");
      } else if (userAgent.match(/Mac/g)) {
        devices.push("Mac");
        devices.push("computer");
      } else if (userAgent.match(/Android/g)) {
        devices.push("Android");

        if (userAgent.match(/Mobile/g)) {
          devices.push("phone");
        } else {
          devices.push("tablet");
        }
      } else {
        devices.push("PC");
        devices.push("computer");
      }

      localStorage.deviceType = JSON.stringify(devices);

      return devices;
    },

    setHTMLDevices: function() {
      var devices = this.getDeviceType();

      var body = document.body;
      body.className = devices.join(" ");
    },

    getStylesheet: function() {
      var index = 0;

      for (var i = 0; i < document.styleSheets.length; i++) {
        if (document.styleSheets[i].href && document.styleSheets[i].href.indexOf("total.css")) {
          index = i;
          break;
        }
      }

      return document.styleSheets[index];
    },

    getStylesheetRules: function() {
      var stylesheet = this.getStylesheet();
      if (!stylesheet) {
        return {};
      }

      var rules = stylesheet.cssRules || stylesheet.rules;

      return rules;
    },

    getCSSVars: function() {
      var rules = this.getStylesheetRules();

      var lastRule = rules[rules.length - 1];
      var noQuotes = this.removeQuotes(lastRule.style.content);
      return JSON.parse(noQuotes);
    },

    removeQuotes: function(string) {
      if (typeof string === 'string' || string instanceof String) {
        string = string.replace(/^['"]+|\s+|\\|(;\s?})+|['"]$/g, '');
      }
      return string;
    }
  }

  return new Globals();
});
define('helpers',[], function() {
  return {
    parentEleWithClassname: function(ele, className) {
      if (ele == null || !ele.classList) {
        return false;
      }

      if (ele.classList.contains(className)) {
        return ele;
      }

      return this.parentEleWithClassname(ele.parentNode, className);
    },

    parentEleIsElement: function(ele, parent) {
      if (ele == null) {
        return false;
      }

      if (ele == parent) {
        return ele;
      }

      return this.parentEleIsElement(ele.parentNode, parent);
    },

    screenToWorld: function(settings, x, y) {
      return {
        x: (x - settings.offsetX) / settings.scale,
        y: (y - settings.offsetY) / settings.scale
      };
    },

    worldToScreen: function(settings, x, y) {
      return {
        x: (x) * settings.scale + settings.offsetX,
        y: (y) * settings.scale + settings.offsetY
      };
    },

    getGuid: function() {
      return "T^" + Date.now() + "" + Math.round(Math.random() * 1000000);
    },

    isLocalGuid: function(id) {
      return id.indexOf("T^") === 0;
    },

    clone: function(obj) {
      var newObj = {};
      for (var prop in obj) {
        newObj[prop] = obj[prop];
      }

      return newObj;
    },

    cloneArray: function(array) {
      var arr = array.slice(0);

      for (var i = 0; i < array.length; i++) {
        if (typeof(array[i]) == "object") {
          //recursion
          arr[i] = this.cloneArray(array[i]);
        }
      }
      return arr;
    },
  };
});
define('class',[], function() {
	/* Simple Javascript inheritance by John Resig */

	var initializing = false,
		fnTest = /xyz/.test(function() {
			xyz;
		}) ? /\b_super\b/ : /.*/;

	// The base CClass implementation (does nothing)
	this.Class = function() {};

	// Create a new CLass that inherits from this class
	Class.extend = function(prop) {
		var _super = this.prototype;

		// Instantiate a base class (but only create the instance, don't run the consutrcutor)
		initializing = true;
		var prototype = new this();
		initializing = false;

		// Copy the properties over onto the new prototype
		for (var name in prop) {
			// Check if we're overwriting an existing function
			prototype[name] = typeof prop[name] == "function" && typeof _super[name] == "function" && fnTest.test(prop[name]) ?
				(function(name, fn) {
				return function() {				
					var tmp = this._super;

					// Add a new ._super() method that is the same method
					// but on the super-class
					this._super = _super[name];

					// The method only need to be bound temporarily, so we
					// remove it when we're done executing

					var ret = fn.apply(this, arguments);
					this._super = tmp;

					return ret;
				};
			})(name, prop[name]) : prop[name];
		}

		// The dummy class constructor

		function Class() {
			// All construction is actually done in the init method
			if (!initializing && this.init)
				this.init.apply(this, arguments);
		}

		// Populate our constructed prototype object
		Class.prototype = prototype;

		// Enforce the constructor to be what we expect
		Class.prototype.constructor = Class;

		// And make this class extendable
		Class.extend = arguments.callee;

		return Class;

	};

	return this.Class;
});
define('gauth',["class", "event"], function(Class, Event) {
  var GAuth = Class.extend({
    CLIENT_ID: '450627732299-2d7jlo96ious5jmdmsd9t7hpclstf7ub.apps.googleusercontent.com',
    INSTALL_SCOPE: 'https://www.googleapis.com/auth/drive.install',
    DRIVE_SCOPE: 'https://www.googleapis.com/auth/drive',
    OPENID_SCOPE: 'openid',

    _user: null,
    _authenticated: null,

    init: function() {
      this._authenticated = false;

      Event.addListener("onlineStatusChanged", (function(status) {
        if (status.online) {
          // try to load gapi and authorize
          console.log("starting auth");
          this.start();
        } else {
          // now offline
        }
      }).bind(this));
    },

    start: function() {
      this.authorize();
    },

    authorize: function() {
      // Try with no popups first.
      gapi.auth.authorize({
        client_id: this.CLIENT_ID,
        scope: [
          this.INSTALL_SCOPE,
          this.DRIVE_SCOPE,
          this.OPENID_SCOPE
        ],
        immediate: true
      }, this._handleAuthResult.bind(this));
    },

    _handleAuthResult: function(token) {
      if (token && !token.error) {
        // logged in

        this._setStatus(true);

        // Refresh the token 10 minutes before it expires
        var expireMS = ((parseInt(token.expires_in) - 600) * 1000);

        setTimeout((function() {
          console.log("Refreshing GAuth token");
          this.authorize();
        }).bind(this), expireMS);

      } else {
        this._setStatus(false);
      }
    },

    authorizeWithPopup: function() {
      gapi.auth.authorize({
        client_id: this.CLIENT_ID,
        scope: [
          this.INSTALL_SCOPE,
          this.DRIVE_SCOPE,
          this.OPENID_SCOPE
        ],
        immediate: false
      }, this._handleAuthResult.bind(this));
    },

    isAuthenticated: function() {
      return this._authenticated;
    },

    _setStatus: function(status) {
      if (this._authenticated == status) {
        // if we are changing to the same status we currently have, skip
        return;
      }

      this._authenticated = status;

      Event.trigger("authenticatedStatusChanged", {
        authenticated: status
      });
    }
  });

  return new GAuth();
});
define('online',["event"], function(Event) {
  var Online = function Online() {
    this.init();
  };

  Online.prototype = {
    _online: null,

    _script: null,

    _retryDelay: 3 * 1000,

    init: function() {
      this._script = document.getElementById("gapiScript");

      window.addEventListener("online", this._onlineEvent.bind(this));
      window.addEventListener("offline", this._offlineEvent.bind(this));
    },

    gapiLoaded: function() {
      console.log("Gapi loaded");
      gapi.load('auth:client,drive-realtime,drive-share', (function() {
        this._setStatus(true);
      }).bind(this));
    },

    gapiLoadError: function() {
      console.warn("Failed to load gapi");
      this._setStatus(false);
      // set a reconnect timer, but only if navigator.online
      window.setTimeout(this._retryScript.bind(this), this._retryDelay);
    },

    isOnline: function() {
      return !!this._online;
    },

    _retryScript: function() {
      if (navigator.onLine) {
        console.log("Retrying to load gapi");
        // We are connected to wifi but might not have a connection,
        // try to reload the script
        this._reloadScript();
      } else {
        // we aren't connected, don't retry
        window.setTimeout(this._retryScript.bind(this), this._retryDelay);
      }
    },

    _reloadScript: function() {
      var parent = this._script.parentElement;
      parent.removeChild(this._script);

      var newScript = document.createElement("script");
      newScript.onError = this._script.onError;
      newScript.async = this._script.async;
      newScript.id = this._script.id;
      newScript.type = this._script.type;
      newScript.src = this._script.src;
      this._script = newScript;

      parent.insertBefore(this._script, parent.children[0]);
    },

    _onlineEvent: function() {
      if (window.gapi) {
        this._setStatus(true);
      } else {
        // reload the script
        this._reloadScript();
      }
    },

    _offlineEvent: function() {
      this._setStatus(false);
      // keep doing everything
    },


    _setStatus: function(online) {
      if (this._online == online) {
        // if we are changing to the same status we currently have, skip
        return;
      }

      this._online = online;
      Event.trigger("onlineStatusChanged", {
        online: online
      });
    },

    waitToComeOnline: function(wait) {
      return new Promise((function(resolve, reject) {
        if (this.isOnline()) {
          resolve();
          return;
        }

        var timer = null;

        function statusChanged(status) {
          if (status.online) {
            window.clearTimeout(timer);
            Event.removeListener("onlineStatusChanged", statusChanged);
            resolve();
          }
        }

        function giveUp() {
          Event.removeListener("onlineStatusChanged", statusChanged);
          reject();
        }

        Event.addListener("onlineStatusChanged", statusChanged);

        timer = window.setTimeout(giveUp, wait);
      }).bind(this))
    },
  }

  return new Online();
});
define('sequentialHelper',["event"], function(Event) {

  function SequentialHelper() {
    this.init();
  }

  SequentialHelper.prototype = {

    _runningActions: null,
    _openFiles: null,

    init: function() {
      // This will have an array for each file
      this._runningActions = {};
      this._openFiles = 0;

      Event.addListener("fileIdChanged", this._fileIdChanged.bind(this));
    },

    startLockedAction: function(fileId, ignoreGlobal) {
      if (!this._runningActions[fileId]) {
        this._runningActions[fileId] = [];
        this._openFiles++;
      }

      var obj = {
        promise: null,
        resolve: null,
        reject: null
      }

      var promise = new Promise(function(resolve, reject) {
        obj.resolve = resolve;
        obj.reject = reject;
      });

      obj.promise = promise;

      // If we are global and the first
      // or there is no global and we are the first
      if ((fileId == "global" || !this._runningActions["global"] || ignoreGlobal) && this._runningActions[fileId].length == 0) {
        obj.resolve();
      }

      this._runningActions[fileId].push(obj);

      return obj.promise;
    },

    endLockedAction: function(fileId) {
      // Remove the first promise
      this._runningActions[fileId].shift();

      // If we have no more promises, delete the file array
      if (this._runningActions[fileId].length == 0) {
        delete this._runningActions[fileId];
        this._openFiles--;

        // If there is only one file left open, and it's a global, start the global action
        if (this._openFiles == 1 && this._runningActions["global"]) {
          this._runningActions["global"][0].resolve();
        }

        return;
      }

      // Resolve the next one
      this._runningActions[fileId][0].resolve();
    },

    startGlobalAction: function() {
      return this.startLockedAction("global");
    },

    endGlobalAction: function() {
      this.endLockedAction("global");

      // This was the last global action, start all of the open files
      for (var file in this._runningActions) {
        this._runningActions[file][0].resolve();
      }
    },

    hasActions: function() {
      return this._openFiles != 0;
    },

    _fileIdChanged: function(e) {
      if (this._runningActions[e.oldId]) {
        this._runningActions[e.newId] = this._runningActions[e.oldId];
        delete this._runningActions[e.oldId];
      }
    },
  }

  return new SequentialHelper();

});
define('bezierCurve',[], function() {

  function BezierCurve() {
    this.init();
  }

  BezierCurve.prototype = {
    _rhs: null,
    _controlPoints: null,
    _tmp: null,
    _length: null,

    init: function() {
      this._length = 0;

      this._rhs = [
        [],
        []
      ];
      this._controlPoints = [];
      this._tmp = [];

      // pre-allocate
      for (var i = 0; i < 2000; i++) {
        this._tmp[i] = 1.0;
        this._rhs[0][i] = 1.0;
        this._rhs[1][i] = 1.0;
      }
    },

    getCurveControlPoints: function(knots) {      
      var n = knots.length - 1;
      this._length = n;
      this._controlPoints.length = n;

      if (n < 1) {
        console.error("Must have at least two knots");
        return;
      }

      if (n == 1) {
        // Special case: should be a line
        var firstControlPoint = [
          (2 * knots[0][0] + knots[1][0]) / 3, (2 * knots[0][1] + knots[1][1]) / 3
        ];

        var secondControlPoint = [
          2 * firstControlPoint[0] - knots[0][0],
          2 * firstControlPoint[1] - knots[0][1]
        ];

        return [[
          firstControlPoint,
          secondControlPoint
        ]];
      }

      // Calculate first Bezier control points
      // Right hand side vector

      // Set right hand side X and Y values
      this._rhs[0][0] = knots[0][0] + 2 * knots[1][0];
      this._rhs[1][0] = knots[0][1] + 2 * knots[1][1];

      for (var i = 1; i < n - 1; ++i) {
        this._rhs[0][i] = 4 * knots[i][0] + 2 * knots[i + 1][0];
        this._rhs[1][i] = 4 * knots[i][1] + 2 * knots[i + 1][1];
      }

      this._rhs[0][n - 1] = (8 * knots[n - 1][0] + knots[n][0]) / 2;
      this._rhs[1][n - 1] = (8 * knots[n - 1][1] + knots[n][1]) / 2;

      // Get first control points x-values
      this.getFirstControlPoints(this._rhs);

      for (var i = 0; i < n; ++i) {
        if (typeof(this._controlPoints[i]) == "undefined") {
          this._controlPoints[i] = [
            new Array(2),
            new Array(2),
          ];
        }

        // First control point
        this._controlPoints[i][0][0] = this._rhs[0][i];
        this._controlPoints[i][0][1] = this._rhs[1][i];

        // Second control point
        if (i < n - 1) {
          this._controlPoints[i][1][0] = 2 * knots[i + 1][0] - this._rhs[0][i + 1];
          this._controlPoints[i][1][1] = 2 * knots[i + 1][1] - this._rhs[1][i + 1];
        } else {
          this._controlPoints[i][1][0] = (knots[n][0] + this._rhs[0][n - 1]) / 2;
          this._controlPoints[i][1][1] = (knots[n][1] + this._rhs[1][n - 1]) / 2;
        }
      }

      return this._controlPoints;
    },

    getFirstControlPoints: function() {
      var n = this._length;
      var b = 2.0;

      this._rhs[0][0] /= b;
      this._rhs[1][0] /= b;

      for (var i = 1; i < n; i++) { // Decomposition and forward substitution
        this._tmp[i] = 1 / b;

        if (i < n - 1) {
          b = 4 - this._tmp[i];
        } else {
          b = 3.5 - this._tmp[i];
        }

        this._rhs[0][i] -= this._rhs[0][i - 1];
        this._rhs[0][i] /= b;

        this._rhs[1][i] -= this._rhs[1][i - 1];
        this._rhs[1][i] /= b;
      }

      for (var i = n - 1; i >= 0; i--) {
        this._rhs[0][i - 1] -= this._tmp[i] * this._rhs[0][i];
        this._rhs[1][i - 1] -= this._tmp[i] * this._rhs[1][i];
      }
    },
  }

  return new BezierCurve();
});
define('components/drawCanvas',["class", "helpers", "bezierCurve"], function(Class, Helpers, BezierCurve) {
  var DrawCanvas = Class.extend({
    _canvas: null,
    _ctx: null,
    _settings: null,

    // Holds at most one action
    _tempCanvas: null,
    _tempCtx: null,

    _useCurves: null,

    init: function(canvas, settings) {
      this._canvas = canvas;
      this._ctx = canvas.getContext("2d");
      this._settings = settings;

      this._useCurves = true;

      this._backCanvas = document.createElement("canvas");
      this._backCtx = this._backCanvas.getContext("2d");
      //this._backCtx.lineJoin = "round";
      //this._backCtx.lineCap = "round";

      this._tempCanvas = document.createElement("canvas");
      this._tempCtx = this._tempCanvas.getContext("2d");
      //this._tempCtx.lineJoin = "round";
      //this._tempCtx.lineCap = "round";
    },

    useCurves: function(value) {
      this._useCurves = value;
    },

    // Creates a back canvas and draws all the actions to it and renders it on the main canvas
    doAll: function(actions) {
      this._backCanvas.width = this._canvas.width;
      this._backCanvas.height = this._canvas.height;

      this._clearCanvas(this._backCanvas, this._backCtx);

      // Also clear the temp canvas
      this._clearCanvas(this._tempCanvas, this._tempCtx);

      for (var i = 0; i < actions.length; i++) {
        var action = actions[i];

        this._doAction(this._backCtx, action);
      }
    },

    // The action is done to a temporary canvas
    doTemporaryAction: function(action) {
      this._tempCanvas.width = this._canvas.width;
      this._tempCanvas.height = this._canvas.height;

      this._clearCanvas(this._tempCanvas, this._tempCtx);

      this._doAction(this._tempCtx, action);
    },

    addAction: function(action) {
      this._doAction(this._backCtx, action);

      // Clears the temp canvas when you add something to the back
      this._clearCanvas(this._tempCanvas, this._tempCtx);
    },

    // Clears the main screen
    clear: function() {
      this._clearCanvas(this._canvas, this._ctx);
    },

    _clearCanvas: function(canvas, ctx) {
      ctx.setTransform(this._settings.scale, 0, 0, this._settings.scale, this._settings.offsetX, this._settings.offsetY);

      var topLeft = Helpers.screenToWorld(this._settings, 0, 0);
      var bottomRight = Helpers.screenToWorld(this._settings, canvas.width, canvas.height);

      ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
    },

    render: function() {
      this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
      this._ctx.drawImage(this._backCanvas, 0, 0, this._backCanvas.width, this._backCanvas.height);
      this._ctx.drawImage(this._tempCanvas, 0, 0, this._tempCanvas.width, this._tempCanvas.height);
    },

    _doAction: function(ctx, action) {
      if (action.type == "stroke") {

        this._drawStroke(ctx, action.value);
      }
    },

    updateSettings: function(settings) {
      this._settings = settings;
    },

    _drawStroke: function(ctx, stroke) {
      if (stroke.points.length < 2) {
        return;
      }

      var controlPoints = stroke.controlPoints;
      var points = stroke.points;

      var point = points[0];

      var lineWidth = stroke.width;
      if (stroke.lockWidth) { // the width stays the same regardless of zoom
        lineWidth /= this._settings.scale;
      }

      ctx.lineJoin = "round";
      ctx.lineWidth = lineWidth;
      ctx.strokeStyle = stroke.color;
      ctx.lineCap = "round";

      ctx.beginPath();
      ctx.moveTo(point.x, point.y);

      for (var i = 1; i < points.length; i++) {
        point = points[i];

        // Curve the first one, even if we are using lines
        if (this._useCurves || i == 1) {
          var cp1 = controlPoints[i - 1][0];
          var cp2 = controlPoints[i - 1][1];
          ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], point[0], point[1]);
        }
        else
        {
          ctx.lineTo(point[0], point[1]);
        }
      }

      ctx.stroke();
    },
  });

  return DrawCanvas;

  /*
  drawAll(actions) // Draw all actions to a back canvas
  drawTemporary(action) // draw action on front canvas
  addAction(action) // add action to back canvas
  */

});
define('components/manipulateCanvas',["components/drawCanvas", "helpers"], function(DrawCanvas, Helpers) {

  var ManipulateCanvas = DrawCanvas.extend({
    zoom: function(x, y, dScale) {
      // Can't zoom that far!
      if (this._settings.scale + dScale < .001 || this._settings.scale + dScale > 20000) {
        return false;
      }

      var world = Helpers.screenToWorld(this._settings, x, y);
      this._settings.scale += dScale;
      var scr = Helpers.worldToScreen(this._settings, world.x, world.y);

      var diffScr = {
        x: x - scr.x,
        y: y - scr.y
      };

      this._settings.offsetX += diffScr.x; // * this._settings.scale;
      this._settings.offsetY += diffScr.y; // * this._settings.scale;

      return true;
    },

    pan: function(dx, dy) {
      this._settings.offsetX += dx;
      this._settings.offsetY += dy;

      return true;
    },

    panTo: function(x, y) {
      this._settings.offsetX = x;
      this._settings.offsetY = y;
    }
  });

  return ManipulateCanvas;
});
define('components/thumbnail',["class", "globals", "helpers", "components/manipulateCanvas"], function(Class, g, Helpers, ManipulateCanvas) {

  var Thumbnail = Class.extend({
    _canvas: null,
    _thumbnailWidth: null,
    _thumbnailHeight: null,

    init: function() {
      var canvas = document.createElement("canvas");

      this.setThumbnailSizes();

      canvas.width = this._thumbnailWidth;
      canvas.height = this._thumbnailHeight;

      this._canvas = canvas;
    },

    render: function(settings, actions) {

      var manipulateCanvas = new ManipulateCanvas(this._canvas, settings);

      // Find out what world point is in the middle
      var centerScreen = {
        x: window.innerWidth / 2,
        y: window.innerHeight / 2
      };
      var centerWorld = Helpers.screenToWorld(settings, centerScreen.x, centerScreen.y);

      var scale = Math.min(this._canvas.width / window.innerWidth, this._canvas.height / window.innerHeight);
      var zoomDiff = (settings.scale * scale) - settings.scale;
      manipulateCanvas.zoom(0, 0, zoomDiff);

      // Now that we have zoomed, find the middle of the canvas
      var centerScreenAfter = {
        x: this._canvas.width / 2,
        y: this._canvas.height / 2
      };

      // And where the middle point was from before
      var centerScreenPointAfter = Helpers.worldToScreen(settings, centerWorld.x, centerWorld.y);

      // pan the difference
      var diffScreen = {
        x: centerScreenAfter.x - centerScreenPointAfter.x,
        y: centerScreenAfter.y - centerScreenPointAfter.y
      };

      manipulateCanvas.pan(diffScreen.x, diffScreen.y);

      manipulateCanvas.doAll(actions);
      manipulateCanvas.render();

      return this._canvas.toDataURL("image/png");
    },


    setThumbnailSizes: function() {

      var space = 15;
      var thumbnailHeight = 200;
      var thumbnailWidth = 300;

      if (g.isComputer()) {
        space = 15;
        thumbnailHeight = 200;
        thumbnailWidth = 300;
      }
      else if (g.isTablet()) {
        space = 15;
        thumbnailHeight = 200;
        thumbnailWidth = 330;
      }
      else if (g.isPhone()) {
        space = 10;
        thumbnailHeight = 100;
        thumbnailWidth = 160;
      }


      var stylesheet = g.getStylesheet();
      if (stylesheet) {

        var rules = g.getStylesheetRules();

        var newRules = [];

        newRules.push("#files-list { padding-top: "+space+"px !important; }");

        newRules.push("#files-list li {"+
          "width: "+(thumbnailWidth)+"px;"+
          "padding: 0px "+(space/2)+"px "+space+"px "+(space/2)+"px;"+
          "}");

        newRules.push("#files-list .create .icon { font-size: "+(thumbnailHeight * 0.5)+"px; }");

        newRules.push("#files-list .create, #files-list .thumbnail, #files-list .overlay, #files-list .thumbnail-info {"+
          "height: "+thumbnailHeight+"px !important;"+
          "}");


        newRules.forEach(function(rule) {
          stylesheet.insertRule(rule, rules.length);
        });

      }

      this._thumbnailHeight = thumbnailHeight * window.devicePixelRatio;
      this._thumbnailWidth = thumbnailWidth * window.devicePixelRatio;
    }
  });

  return new Thumbnail();
});
define('dataLayer/file',["class", "event", "helpers", "sequentialHelper", "bezierCurve", "components/thumbnail"], function(Class, Event, Helpers, SequentialHelper, BezierCurve, Thumbnail) {
  var File = Class.extend({
    fileInfoPromise: null,

    _cachedActions: null,

    _backing: null,
    _driveBacking: null,

    _addedCallback: null,
    _removedCallback: null,

    _syncPromise: null,

    init: function(backing) {
      // Create our backing instance
      this._backing = backing;
    },

    hasLocalActions: function(fileId) {
      return this._backing.load(fileId)
        .then((function(fileInfo) {
          return this._backing.getActions()
        }).bind(this))
        .then((function(actions) {
          return this._backing.close()
            .then(function() {
              return actions.local.length !== 0;
            })
        }).bind(this));
    },

    remoteActionsMatch: function(fileId, driveBacking) {
      return Promise.all([this._backing.load(fileId), driveBacking.load(fileId)])
        .then((function() {
          var localActionsPromise = this._backing.getActions();
          var remoteActionsPromise = driveBacking.getActions();

          return Promise.all([localActionsPromise, remoteActionsPromise])
            .then(function(results) {
              var localActions = results[0];
              var remoteActions = results[1];

              // If the lengths don't match, they aren't equal
              if (localActions.remote.length != remoteActions) {
                return false;
              }

              for (var i = 0; i < localActions.remote.length; i++) {
                if (localActions.remote[i].id != remoteActions[i]) {
                  return false;
                }
              }

              return true;
            });
        }).bind(this));
    },

    load: function(fileId) {
      var fileInfoPromise = this._backing.load(fileId);

      return fileInfoPromise
        .then((function(fileInfo) {
          return this._backing.getActions()
        }).bind(this))
        .then((function(actions) {
          var actionsObj = {
            remoteActions: [],
            localActions: [],
            redoStack: []
          };

          actionsObj.remoteActions = actions.remote;
          actionsObj.localActions = actions.local;

          this._cachedActions = actionsObj;

          this.fileInfoPromise = fileInfoPromise;
          return this;
        }).bind(this));
    },

    create: function(file) {
      return this._backing.create(file)
        .then((function() {
          return this.load(file.id);
        }).bind(this))
        .
      catch (function(error) {
        console.error(error, error.stack, error.message);
      });
    },

    rename: function(newName) {

      return this.fileInfoPromise.then((function(fileInfo) {
        var newTime = Date.now();

        fileInfo.name = newName;
        fileInfo.localModifiedTime = newTime;
        Event.trigger("fileRenamed", fileInfo);
        Event.trigger("fileModified", fileInfo);

        this.fileInfoPromise = Promise.resolve(fileInfo);



        var promises = [];

        promises.push(this.fileInfoPromise.then((function() {
          return this._backing.updateLocalModifiedTime(newTime);
        }).bind(this)));

        promises.push(this._backing.rename(newName));

        if (this._driveBacking) {
          promises.push(SequentialHelper.startLockedAction(fileInfo.id)
            .then((function() {
              return this._driveBacking.rename(newName);
            }).bind(this))
            .
            catch (function(error) {
              console.error(error);
            })
            .then((function() {
              SequentialHelper.endLockedAction(fileInfo.id);
            }).bind(this)))

        }

        return Promise.all(promises)
      }).bind(this));
    },

    startDrive: function(driveBacking) {
      console.log("starting");
      // process things on drive for updates
      driveBacking.listen(this.remoteActionsAdded.bind(this), this.remoteActionsRemoved.bind(this));


      return this.fileInfoPromise
        .then((function(fileInfo) {
          console.log("Starting drive for file", fileInfo.id);
          return this.sync(driveBacking, true)
        }).bind(this))
        .then((function() {
          this._driveBacking = driveBacking;
        }).bind(this))
        .
      catch (function(error) {
        console.error(error, error.stack, error.message);
      })
    },

    sync: function(drive, syncActions) {
      var driveBacking = this._driveBacking || drive;
      if (!driveBacking) {
        debugger;
      }

      // if this fileId exists on drive, great, it's a match
      // if it doesn't, then it either has never been uploaded, or was deleted on the server
      // regardless, it's open, so we should upload it to drive
      this._syncPromise = this.fileInfoPromise
        .then((function(fileInfo) {
          return driveBacking._parent.getFileInfo(fileInfo.id)
            .
          catch (function() {
            // File doesn't exist
            return undefined;
          })
            .then((function(driveFileInfo) {

              console.log("Starting file sync", fileInfo.id);

              var promises = [];



              if (driveFileInfo !== undefined) {
                console.log("Found file", fileInfo.id, "on drive");

                // the file was found on drive
                // load it and sync actions
                // sync actions

                if (driveFileInfo.title != fileInfo.name) {
                  // if we haven't seen an update from drive
                  if (driveFileInfo.driveModifiedTime == fileInfo.driveModifiedTime) {
                    // then rename it on drive
                    promises.push(driveBacking.load(fileInfo.id)
                      .then((function() {
                        return driveBacking.rename(fileInfo.name)

                      }).bind(this)));
                  } else {
                    // Update it locally
                    promises.push(this.rename(driveFileInfo.title));
                  }
                }

                if (syncActions) {
                  promises.push(this._syncRemoteActionsFromDrive(driveBacking));
                }

              } else {
                console.log("File not found on drive", fileInfo.id);
                // this file was not found
                // so we will create a new file on drive,
                // and then copy everything over to it
                var oldId = fileInfo.id;

                promises.push(
                  SequentialHelper.startLockedAction(oldId, true)
                  .then(function() {
                    return driveBacking.create(fileInfo)
                  })
                  .then((function(newFile) {
                    // Google saved a file, redo the id of the file locally to match drive
                    return this._backing.replaceFileId(newFile.id)
                      .then((function() {
                        return this.load(newFile.id);
                      }).bind(this))
                      .then((function() {

                        return this._moveSettings(oldId)
                      }).bind(this))
                      .then(function() {
                        Event.trigger("fileIdChanged", {
                          oldId: oldId,
                          newId: newFile.id
                        });
                      })
                      .then((function() {
                        return this._backing.getActions();
                      }).bind(this))
                      .then((function(localActions) {
                        var allActions = localActions.remote.concat(localActions.local);
                        return this._sendAllActions(allActions, driveBacking)
                      }).bind(this))
                      .then((function() {
                        return driveBacking.rename(fileInfo.name);
                      }).bind(this))
                      .
                    catch ((function(error) {
                      console.error(error);
                    }).bind(this))
                      .then(function() {
                        SequentialHelper.endLockedAction(newFile.id);
                      });

                  }).bind(this))
                );
              }

              return Promise.all(promises)
            }).bind(this))
        }).bind(this))
        .then((function() {
          this._syncPromise = null;
        }).bind(this))
        .
      catch (function(error) {
        console.error(error, error.stack, error.message);
      })
        .then((function() {
          return this.fileInfoPromise;
        }).bind(this))
        .then(function(fileInfo) {
          console.log("Completed file sync", fileInfo.id);
        });

      return this._syncPromise;
    },

    listen: function(addedCallback, removedCallback) {
      this._addedCallback = addedCallback;
      this._removedCallback = removedCallback;
    },

    stopListening: function() {
      this._addedCallback = null;
      this._removedCallback = null;
    },

    getActions: function() {
      return this._cachedActions.remoteActions.concat(this._cachedActions.localActions);
    },

    localSettings: function(settings) {
      return this.fileInfoPromise
        .then((function(fileInfo) {

          if (settings) {
            localStorage[fileInfo.id] = JSON.stringify(settings);
          }

          if (!localStorage[fileInfo.id]) {
            localStorage[fileInfo.id] = JSON.stringify({
              offsetX: 0,
              offsetY: 0,
              scale: 1,
              color: "#000",
              tools: {
                point: "pencil",
                gesture: null,
                scroll: "pan"
              }
            });
          }

          return JSON.parse(localStorage[fileInfo.id]);
        }).bind(this));
    },

    _moveSettings: function(oldId) {
      if (localStorage[oldId]) {
        return this.fileInfoPromise
          .then(function(fileInfo) {
            localStorage[fileInfo.id] = localStorage[oldId];
            delete localStorage[oldId];
          });
      }

      return Promise.resolve();
    },

    undo: function() {
      if (this._driveBacking) {
        return this._driveBacking.undo();
      }

      if (this._cachedActions.localActions.length === 0) {
        return Promise.resolve(false); // no actions to undo
      } else {
        var lastAction = this._cachedActions.localActions.pop();
        this._cachedActions.redoStack.push(lastAction);

        return this._backing.removeLocalAction(lastAction.id)
          .then((function() {
            return this.fileInfoPromise;
          }).bind(this))
          .then((function(fileInfo) {
            fileInfo.localModifiedTime = Date.now();
            this.fileInfoPromise = Promise.resolve(fileInfo);
            Event.trigger("fileModified", fileInfo);

            return this._backing.updateLocalModifiedTime(fileInfo.localModifiedTime);
          }).bind(this));
      }
    },

    redo: function() {
      if (this._driveBacking) {
        return this._driveBacking.redo();
      }

      if (this._cachedActions.redoStack.length === 0) {
        return Promise.resolve(false); // no actions to undo
      } else {
        var action = this._cachedActions.redoStack.pop();
        return this._addAction(action);
      }
    },

    addAction: function(action) {
      this._cachedActions.redoStack.length = 0;
      return this._addAction(action);
    },

    _addAction: function(action) {
      this._cachedActions.localActions.push(action);

      var promises = [];

      promises.push(this.fileInfoPromise.then((function(fileInfo) {
        fileInfo.localModifiedTime = Date.now();
        this.fileInfoPromise = Promise.resolve(fileInfo);
        Event.trigger("fileModified", fileInfo);

        return this._backing.updateLocalModifiedTime(fileInfo.localModifiedTime);
      }).bind(this)));

      promises.push(this._backing.addLocalAction(action));

      if (this._driveBacking) {
        var newAction = this._prepareForDrive(Helpers.clone(action));
        promises.push(this._driveBacking.addAction(newAction));
      }

      return Promise.all(promises)
        .then((function() {
          return this.fileInfoPromise;
        }).bind(this))
        .
      catch (function(error) {
        console.error(error, error.stack, error.message);
      });
    },

    delete: function() {
      return this.fileInfoPromise.then((function(fileInfo) {
        return this.close()
          .then((function() {
            delete localStorage[fileInfo.id];
            return this._backing._parent.deleteFile(fileInfo.id);
          }).bind(this));
      }).bind(this));
    },

    close: function() {
      var prom = Promise.resolve();

      // Only close after sync is done, if sync is running
      if (this._syncPromise) {
        prom = this._syncPromise;
      }

      // If we loaded a file
      if (this.fileInfoPromise) {
        return prom.then((function() {
          this.fileInfoPromise.then((function() {
            // Explicitly allow garbage collection
            this._cachedActions.length = 0;

            this.fileInfoPromise = Promise.reject(new Error("File has been closed"));
          }).bind(this));

          var promises = [];

          promises.push(this._backing.close());

          if (this._driveBacking) {
            this._driveBacking.stopListening();

            promises.push(this._driveBacking.close());
            this._driveBacking = null;
          }

          return Promise.all(promises);
        }).bind(this))
      } else {
        return prom;
      }

    },

    _syncRemoteActionsFromDrive: function(driveBacking) {
      function isEqual(arr1, arr2) {
        if (arr1.length != arr2.length) {
          return false;
        }

        for (var i = 0; i < arr1.length; i++) {
          if (arr1[i].id != arr2[i].id) {
            return false;
          }
        }

        return true;
      }

      return this.fileInfoPromise.then((function(fileInfo) {

        var driveActionsPromise = driveBacking.load(fileInfo.id)
          .then((function() {
            return driveBacking.getActions()
          }).bind(this));


        // TODO: THIS LINE SUCKS! the file is already closed, can't get the actions
        var localActionsPromise = this._backing.getActions();

        return Promise.all([fileInfo, driveActionsPromise, localActionsPromise]);
      }).bind(this))
        .then((function(results) {
          var fileInfo = results[0]
          var remoteActions = results[1];
          var localActions = results[2];

          var promises = [];


          var shorter = remoteActions.length < localActions.remote.length ? remoteActions : localActions.remote;
          var diverges = -1;

          for (var j = 0; j < shorter.length; j++) {
            if (remoteActions[j].id != localActions.remote[j].id) {
              diverges = j;
              break;
            }
          }

          // Did we get new changes from drive that we should notify about
          var sendUpdate = false;

          var items;

          // Only modify things if we need to
          if (diverges !== -1 || remoteActions.length != localActions.remote.length) {
            console.log("Differences between remote and local actions", fileInfo.id);
            sendUpdate = true;

            if (diverges != -1) {
              // get the remote actions after the diverge
              var remoteActionsAfterDiverge = remoteActions.slice(diverges);

              // we need to add indexes to these items
              items = this._indexify(remoteActionsAfterDiverge, diverges);
              items = items.map(this._convertFromDrive);

              // remove the actions in local after the diverge
              promises.push(this._backing.removeRemoteActions(diverges, localActions.remote.length - diverges)
                .then((function() {

                  // insert the remote actions after diverge into local actions
                  this._backing.addRemoteActions(diverges, items);
                }).bind(this)));

              // and fix our array
              this._cachedActions.remoteActions.splice.apply(this._cachedActions.remoteActions, [diverges, this._cachedActions.remoteActions.length - diverges].concat(items));
            } else if (shorter == remoteActions) {
              // remove the actions after diverge from local
              promises.push(this._backing.removeRemoteActions(remoteActions.length, localActions.remote.length - remoteActions.length));
              this._cachedActions.remoteActions.splice(remoteActions.length, localActions.remote.length - remoteActions.length);
            } else {
              // shorter must be the local one
              // add the remote actions after the local ones
              var remoteActionsAfterLocal = remoteActions.slice(localActions.remote.length);

              items = this._indexify(remoteActionsAfterLocal, localActions.remote.length);
              items = items.map(this._convertFromDrive);

              promises.push(this._backing.addRemoteActions(localActions.remote.length, items));

              this._cachedActions.remoteActions.splice.apply(this._cachedActions.remoteActions, [this._cachedActions.remoteActions.length, 0].concat(items));
            }

            if (!isEqual(this._cachedActions.remoteActions, remoteActions)) {
              debugger;
            }


            // there was a difference, lets fix our cachedActions
            //this._cachedActions.remoteActions = remoteActions;
          }

          // TODO: move this to the end of sync instead of syncing file actions
          promises.push(this._sendAllActions(localActions.local, driveBacking));

          return Promise.all(promises)
            .then((function() {
              if (sendUpdate) {
                return this.updateThumbnail();
              }
            }).bind(this));
        }).bind(this));
    },

    _sendAllActions: function(actions, driveBacking) {
      var promises = [];

      for (var j = 0; j < actions.length; j++) {
        var newAction = this._prepareForDrive(actions[j]);
        promises.push(driveBacking.addAction(newAction));
      }

      return Promise.all(promises);
    },

    remoteActionsAdded: function(data) {
      if (!this.isConnected()) {
        //debugger;
      }

      var promises = [];

      if (data.isLocal) {
        // go through each item to insert
        for (var i = 0; i < data.values.length; i++) {
          // delete them from local
          for (var j = 0; j < this._cachedActions.localActions.length; j++) {
            if (this._cachedActions.localActions[j].id == data.values[i].id) {
              this._cachedActions.localActions.splice(j, 1);
              break;
            }
          }

          promises.push(this._backing.removeLocalAction(data.values[i].id));
        }
      }

      // put the items into the remoteActions
      this._cachedActions.remoteActions.splice.apply(this._cachedActions.remoteActions, [data.index, 0].concat(data.values));

      var items = this._indexify(data.values, data.index);
      items = items.map(this._convertFromDrive);

      // insert them into storage
      promises.push(this._backing.addRemoteActions(data.index, items));

      if (this._addedCallback) {
        this._addedCallback({
          isLocal: data.isLocal,
          items: items
        });
      }

      promises.push(this.fileInfoPromise.then((function(fileInfo) {
        if (data.isLocal) {
          Event.trigger("fileModified", fileInfo);
        } else {
          Event.trigger("fileModifiedRemotely", fileInfo);
        }

        fileInfo.localModifiedTime = Date.now();
        this.fileInfoPromise = Promise.resolve(fileInfo);

        return this._backing.updateLocalModifiedTime(fileInfo.localModifiedTime);
      }).bind(this)));

      return Promise.all(promises).
      catch (function() {

      })
        .then((function() {
          return this.updateThumbnail();
        }).bind(this));
    },

    remoteActionsRemoved: function(data) {
      if (!this.isConnected()) {
        // We have since closed
        //debugger;
      }

      // remove it from the remoteActions
      this._cachedActions.remoteActions.splice(data.index, data.values.length);

      var promises = [];
      promises.push(this._backing.removeRemoteActions(data.index, data.values.length));

      if (this._removedCallback) {
        promises.push(this._removedCallback());
      }

      promises.push(this.fileInfoPromise.then(function(fileInfo) {
        fileInfo.localModifiedTime = Date.now();
        this.fileInfoPromise = Promise.resolve(fileInfo);
        Event.trigger("fileModified", fileInfo);

        return this._backing.updateLocalModifiedTime(fileInfo.localModifiedTime);
      }));

      return Promise.all(promises).then((function() {
        return this.updateThumbnail();
      }).bind(this));
    },

    updateDriveModifiedTime: function(time) {
      return this._backing.updateDriveModifiedTime(time);
    },

    updateThumbnail: function() {
      return this.localSettings()
        .then((function(settings) {
          var dataURL = Thumbnail.render(settings, this.getActions());

          return this.fileInfoPromise.then((function(fileInfo) {
            fileInfo.thumbnail = dataURL;
            Event.trigger("thumbnailUpdated", fileInfo);
            this.fileInfoPromise = Promise.resolve(fileInfo);

            return this._backing.updateThumbnail(dataURL);
          }).bind(this))
        }).bind(this));
    },

    _indexify: function(actions, startIndex) {
      var items = [];
      // put indexes on the items
      for (var i = 0; i < actions.length; i++) {
        var item = Helpers.clone(actions[i]);
        item.index = i + startIndex;
        items.push(item);
      }

      return items;
    },

    _prepareForDrive: function(action) {
      var newAction = Helpers.clone(action);
      newAction.value = Helpers.clone(action.value);
      delete newAction.value.controlPoints;

      return newAction;
    },

    _convertFromDrive: function(action) {
      var controlPoints = BezierCurve.getCurveControlPoints(action.value.points);
      action.value.controlPoints = Helpers.cloneArray(controlPoints);

      if (action.value.controlPoints == undefined) {
        debugger;
      }

      return action;
    },

    isConnected: function() {
      return !!this._driveBacking;
    }
  });

  return File;
});
define('dataLayer/data',["class", "helpers", "event", "gauth", "online", "sequentialHelper", "dataLayer/file"], function(Class, Helpers, Event, GAuth, Online, SequentialHelper, File) {
  var Data = Class.extend({
    _backing: null,
    _cachedFiles: null,
    _fileReferences: null,

    _driveBacking: null,

    init: function(backing, driveBacking) {
      this._cachedFiles = {};
      this._fileReferences = {};

      this._backing = backing;
      this._driveBacking = driveBacking;

      Event.addListener("fileIdChanged", this._fileIdChanged.bind(this));
    },

    // FILE METHODS
    getFiles: function() {
      return this._backing.getFiles()
        .
      catch (function(error) {
        console.error(error, error.stack, error.message);
        throw error;
      });
    },

    createFile: function() {
      var newFile = {
        id: Helpers.getGuid(),
        name: "Untitled File",
        localModifiedTime: Date.now(),
        driveModifiedTime: "",
        // I don't like this, but it is a 1px transparent png
        thumbnail: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACklEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg==",
      };

      return this._createFile(newFile);
    },

    _createFile: function(fileInfo) {
      var file = new File(new this._backing.instance(this._backing));

      this._fileReferences[fileInfo.id] = 1;

      this._cachedFiles[fileInfo.id] = file.create(fileInfo)
        .then((function(fileInfo, file) {
          Event.trigger("fileAdded", fileInfo);
          return file;
        }).bind(this, fileInfo))
        .
      catch (function(error) {
        console.error(error, error.stack, error.message);
        throw error;
      });

      if (GAuth.isAuthenticated()) {
        this._cachedFiles[fileInfo.id].then((function() {
          file.startDrive(this._newDriveInstance());
        }).bind(this));
      }

      return this._cachedFiles[fileInfo.id];
    },

    loadFile: function(fileId, waitForSync) {
      if (this._cachedFiles[fileId]) {
        this._fileReferences[fileId]++;
        return this._cachedFiles[fileId];
      }

      return this.fileExists(fileId)
        .then((function(exists) {
          if (!exists) {
            throw new Error("This file does not exist");
          }

          // file not already loaded
          var file = new File(new this._backing.instance(this._backing));

          this._fileReferences[fileId] = 1;

          this._cachedFiles[fileId] = file.load(fileId)
            .then((function() {
              return file;
            }).bind(this));


          if (Online.isOnline()) {

            // If we have drive, start drive outside of this promise
            this._cachedFiles[fileId].then((function() {
              var startingDrive = file.startDrive(this._newDriveInstance());

              if (waitForSync) {
                return startingDrive;
              }
            }).bind(this));
          }

          return this._cachedFiles[fileId];
        }).bind(this));
    },

    deleteFile: function(fileId, skipDrive) {
      var promises = [];

      Event.trigger("fileRemoved", fileId);

      if (this._fileReferences[fileId]) {
        delete this._fileReferences[fileId];
      }

      // If it is in the cached files, close the file and remove it
      if (this._cachedFiles[fileId]) {
        var filePromise = this._cachedFiles[fileId];
        delete this._cachedFiles[fileId];

        promises.push(filePromise
          .then((function(file) {
            return this.close(file);
          }).bind(this)));
      }

      if (Helpers.isLocalGuid(fileId)) {
        return this._backing.deleteFile(fileId);
      } else {
        if (!skipDrive && GAuth.isAuthenticated()) {
          return this._driveBacking.deleteFile(fileId)
            .then((function() {
              return this._backing.deleteFile(fileId);
            }).bind(this));
        } else {
          return this._backing.markFileAsDeleted(fileId);
        }
      }
    },

    close: function(file) {
      return file.fileInfoPromise
        .then((function(fileInfo) {
          if (this._fileReferences[fileInfo.id]) {
            this._fileReferences[fileInfo.id]--;
          }

          if (this._fileReferences[fileInfo.id] > 0) {
            // Not actually closing
            return Promise.resolve();
          } else {
            // it is equal to 0
            delete this._fileReferences[fileInfo.id];
            delete this._cachedFiles[fileInfo.id];

            return file.close();

          }
        }).bind(this));
    },

    syncOpenFiles: function() {
      var sequence = Promise.resolve();

      for (var fileId in this._cachedFiles) {
        var filePromise = this._cachedFiles[fileId];

        sequence = sequence.then((function(filePromise) {
          return filePromise;
        }).bind(this, filePromise))
          .then((function(file) {
            var driveInstance = new this._driveBacking.instance(this._driveBacking);
            return file.startDrive(driveInstance);
          }).bind(this));

      }

      return sequence;
    },

    openReferences: function(fileId) {
      if (this._fileReferences[fileId]) {
        return this._fileReferences[fileId];
      }

      return 0;
    },

    _fileIdChanged: function(e) {
      if (this._cachedFiles[e.oldId]) {
        this._fileReferences[e.newId] = this._fileReferences[e.oldId];
        delete this._fileReferences[e.oldId];

        this._cachedFiles[e.newId] = this._cachedFiles[e.oldId];
        delete this._cachedFiles[e.oldId];
      }
    },

    _newDriveInstance: function(driveBacking) {
      return new this._driveBacking.instance(this._driveBacking);
    },


    checkForUpdates: function() {
      if (!GAuth.isAuthenticated()) {
        return Promise.resolve();
      }

      if (SequentialHelper.hasActions()) {
        console.warn("Actions currently running, can't sync");
        return Promise.reject();
      }

      function getFileId(file) {
        return file.id;
      }

      function sortById(file1, file2) {
        return file1.id < file2.id;
      }

      function fileIdsMatch(file1, file2) {
        return file1.id == file2.id;
      }

      function intersectFiles(drive, local, compare) {
        var intersection = [];

        for (var i = 0; i < drive.length; i++) {
          for (var j = 0; j < local.length; j++) {
            if (match(drive[i], local[j], compare)) {
              intersection.push({
                drive: drive[i],
                local: local[j]
              });
              break;
            }
          }
        }

        return intersection;
      }

      function onlyInLeft(array1, array2, compare) {
        var result = [];

        for (var i = 0; i < array1.length; i++) {
          var found = false;

          for (var j = 0; j < array2.length; j++) {
            if (compare(array1[i], array2[j])) {
              found = true;
              break;
            }
          }

          if (!found) {
            result.push(array1[i]);
          }
        }

        return result;
      }

      function match(item1, item2, compare) {
        return compare(item1, item2);
      }

      return SequentialHelper.startGlobalAction()
        .then((function() {

          console.log("Checking for file updates on drive");

          var driveFilesPromise = this._driveBacking.getFiles();
          var localFilesPromise = this._backing.getFiles();
          var locallyDeletedFilesPromise = this._backing.getDeletedFiles();

          return Promise.all([driveFilesPromise, localFilesPromise, locallyDeletedFilesPromise])
            .then((function(results) {
              var remoteFiles = results[0].sort(sortById);
              var localFiles = results[1].sort(sortById);
              var filesDeletedLocally = results[2].sort(sortById);

              var localFileIds = localFiles.map(getFileId);
              var remoteFileIds = remoteFiles.map(getFileId);

              var fileIdsDeletedLocally = filesDeletedLocally.map(getFileId);
              var fileIdsDeletedOnBoth = fileIdsDeletedLocally.filter(function(id) {
                return remoteFileIds.indexOf(id) === -1;
              });

              var filesOnlyOnDrive = onlyInLeft(remoteFiles, localFiles, fileIdsMatch);
              var filesOnlyOnLocal = onlyInLeft(localFiles, remoteFiles, fileIdsMatch);
              var filesOnBoth = intersectFiles(remoteFiles, localFiles, fileIdsMatch);

              var promises = [];
              var sequence = Promise.resolve();

              // Delete all the files that were deleted on both local and remote
              fileIdsDeletedOnBoth.map((function(id) {
                promises.push(this._backing.deleteFile(id));
              }).bind(this));


              sequence = filesOnlyOnDrive.reduce((function(sequence, driveFileInfo) {

                return sequence.then((function(driveFileInfo) {
                  var deletedLocally = fileIdsDeletedLocally.indexOf(driveFileInfo.id) !== -1;
                  return this._fileNotFoundLocally(driveFileInfo, deletedLocally);
                }).bind(this, driveFileInfo));

              }).bind(this), sequence);


              sequence = filesOnlyOnLocal.reduce((function(sequence, localFileInfo) {

                return sequence.then((function(localFileInfo) {
                  // we don't have it on remote, and we also marked it as deleted locally
                  var deletedLocally = fileIdsDeletedLocally.indexOf(localFileInfo.id) !== -1;
                  return this._fileNotFoundOnRemote(localFileInfo, deletedLocally);
                }).bind(this, localFileInfo));

              }).bind(this), sequence);


              sequence = filesOnBoth.reduce((function(sequence, files) {

                return sequence
                  .then((function(files) {
                    var driveFileInfo = files.drive;
                    var localFileInfo = files.local;


                    var tempFile = new File(new this._backing.instance(this._backing));
                    var hasLocalActionsPromise = tempFile.hasLocalActions(localFileInfo.id);

                    return hasLocalActionsPromise.then((function(hasLocalActions) {

                      if (
                        driveFileInfo.modifiedDate != localFileInfo.driveModifiedTime ||
                        hasLocalActions ||
                        driveFileInfo.title != localFileInfo.name) {

                        // Let the file check to make sure it is named properly and has all the actions
                        return this.loadFile(localFileInfo.id, true)
                          .then((function(fileObj) {

                            return fileObj.updateDriveModifiedTime(driveFileInfo.modifiedDate)
                              .then((function() {
                                return this.close(fileObj);
                              }).bind(this));
                          }).bind(this));
                      } else {
                        console.log("No local changes, skipping", localFileInfo.id);
                      }
                    }).bind(this));

                  }).bind(this, files));
              }).bind(this), sequence);

              promises.push(sequence);

              return Promise.all(promises)
            }).bind(this))
            .
          catch (function(error) {
            console.error(error, error.stack, error.message);
          })
            .then((function() {
              console.log("Completed checking for Drive updates");
            }).bind(this))
            .
          catch (function(error) {
            console.error(error, error.stack, error.message);
          });
        }).bind(this))
        .then(function() {
          SequentialHelper.endGlobalAction();
        });
    },


    _fileNotFoundLocally: function(fileInfo, deletedLocally) {
      if (deletedLocally) {
        console.log(fileInfo.id, "was deleted");
        // we need to see if the file remote actions match to
        // know whether we should actually delete it remotely.
        var tempFile = new File(new this._backing.instance(this._backing));
        return tempFile.remoteActionsMatch(fileInfo.id, this._newDriveInstance())
          .then((function(actionsMatch) {
            if (actionsMatch) {
              console.log("Deleting", fileInfo.id, "on remote");
              // delete it on the remote
              return this.deleteFile(fileInfo.id);
            } else {
              // unmark as deleted and load it so it will sync
              console.log("Readding", fileInfo.id, "on remote");
              var loadClose = this.loadFile(fileInfo.id)
                .then((function(file) {
                  return this.close(file);
                }).bind(this));

              return Promise.all([this._backing.unmarkFileAsDeleted(fileInfo.id), loadClose]);
            }
          }).bind(this));
      } else {

        return this._createFileFromRemote(fileInfo);
      }
    },

    _fileNotFoundOnRemote: function(fileInfo, deletedLocally) {
      if (deletedLocally) {
        return this.deleteFile(fileInfo.id, true);
      }

      // TODO: check if we deleted it remotely
      var deletedRemotely = !Helpers.isLocalGuid(fileInfo.id);

      if (deletedRemotely) {
        return this.deleteFile(fileInfo.id, true);
      }

      // load it and let it sync
      return this.loadFile(fileInfo.id, true)
        .then((function(file) {
          return this.close(file);
        }).bind(this));
    },

    getRemoteFileInfo: function(fileId) {
      return this.isReadableRemoteFile(fileId)
        .then((function(readable) {
          if (readable) {
            return this._driveBacking.getFileInfo(fileId);
          } else {
            throw "File does not exist or is not readable";
          }
        }).bind(this))
    },

    loadFileFromRemote: function(fileId) {
      return this.getRemoteFileInfo(fileId)
        .then((function(driveFileInfo) {
          return Promise.all([this._driveBacking.touchFile(fileId), this._createFileFromRemote(driveFileInfo)])
            .then(function(results) {
              return results[1];
            });
        }).bind(this))
    },

    _createFileFromRemote: function(driveFileInfo) {
      var newFile = {
        id: driveFileInfo.id,
        name: driveFileInfo.title,
        localModifiedTime: Date.now(),
        driveModifiedTime: driveFileInfo.modifiedDate,

        // I don't like this, but it is a 1px transparent png
        thumbnail: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACklEQVR4nGMAAQAABQABDQottAAAAABJRU5ErkJggg==",
      };

      return this._createFile(newFile)
        .then((function(file) {
          return this.close(file);
        }).bind(this))
        .then((function() {
          return newFile
        }).bind(this))
    },

    isReadableRemoteFile: function(fileId) {
      if (!Online.isOnline()) {
        return Promise.reject(new Error("Not connected to drive"));
      }

      return this._driveBacking.canReadFile(fileId);
    },

    clearLocal: function() {
      return this._backing.clearAll()
        .then((function() {
          // Reinit a new database
          this._backing.init();
        }).bind(this));
    },

    fileExists: function(fileId) {
      return this._backing.fileExists(fileId);
    }
  });

  return Data;
});
define('db',[], function() {
    
    var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.oIndexedDB || window.msIndexedDB,
        IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange,
        transactionModes = {
            readonly: 'readonly',
            readwrite: 'readwrite'
        };

    var hasOwn = Object.prototype.hasOwnProperty;

    if (!indexedDB) {
        return;
    }

    var defaultMapper = function(value) {
        return value;
    };

    var CallbackList = function() {
        var state,
            list = [];

        var exec = function(context, args) {
            if (list) {
                args = args || [];
                state = state || [context, args];

                for (var i = 0, il = list.length; i < il; i++) {
                    list[i].apply(state[0], state[1]);
                }

                list = [];
            }
        };

        this.add = function() {
            for (var i = 0, il = arguments.length; i < il; i++) {
                list.push(arguments[i]);
            }

            if (state) {
                exec();
            }

            return this;
        };

        this.execute = function() {
            exec(this, arguments);
            return this;
        };
    };

    var Deferred = function(func) {
        var state = 'progress',
            actions = [
                ['resolve', 'done', new CallbackList(), 'resolved'],
                ['reject', 'fail', new CallbackList(), 'rejected'],
                ['notify', 'progress', new CallbackList()],
            ],
            deferred = {},
            promise = {
                state: function() {
                    return state;
                },
                then: function( /* doneHandler , failedHandler , progressHandler */ ) {
                    var handlers = arguments;

                    return Deferred(function(newDefer) {
                        actions.forEach(function(action, i) {
                            var handler = handlers[i];

                            deferred[action[1]](typeof handler === 'function' ?
                                function() {
                                    var returned = handler.apply(this, arguments);

                                    if (returned && typeof returned.promise === 'function') {
                                        returned.promise()
                                            .done(newDefer.resolve)
                                            .fail(newDefer.reject)
                                            .progress(newDefer.notify);
                                    }
                                } : newDefer[action[0]]
                            );
                        });
                    }).promise();
                },
                promise: function(obj) {
                    if (obj) {
                        Object.keys(promise)
                            .forEach(function(key) {
                                obj[key] = promise[key];
                            });

                        return obj;
                    }
                    return promise;
                }
            };

        actions.forEach(function(action, i) {
            var list = action[2],
                actionState = action[3];

            promise[action[1]] = list.add;

            if (actionState) {
                list.add(function() {
                    state = actionState;
                });
            }

            deferred[action[0]] = list.execute;
        });

        promise.promise(deferred);

        if (func) {
            func.call(deferred, deferred);
        }

        return deferred;
    };

    var Server = function(db, name) {
        var that = this,
            closed = false;

        this.add = function(table) {
            if (closed) {
                throw new Error('Database has been closed');
            }

            var records = [];
            for (var i = 0; i < arguments.length - 1; i++) {
                records[i] = arguments[i + 1];
            }

            var transaction = db.transaction(table, transactionModes.readwrite),
                store = transaction.objectStore(table),
                deferred = Deferred();

            records.forEach(function(record) {
                var req;
                if (record.item && record.key) {
                    var key = record.key;
                    record = record.item;
                    req = store.add(record, key);
                } else {
                    req = store.add(record);
                }

                req.onsuccess = function(e) {
                    var target = e.target;
                    var keyPath = target.source.keyPath;
                    if (keyPath === null) {
                        keyPath = '__id__';
                    }
                    Object.defineProperty(record, keyPath, {
                        value: target.result,
                        enumerable: true
                    });
                    deferred.notify();
                };
            });

            transaction.oncomplete = function() {
                deferred.resolve(records, that);
            };
            transaction.onerror = function(e) {
                var error = new Error();
                error.dbError = e;
                e.records = records;
                deferred.reject(error);
            };
            transaction.onabort = function(e) {
                var error = new Error();
                error.dbError = e;
                e.records = records;
                deferred.reject(error);
            };
            return deferred.promise();
        };

        this.update = function(table) {
            if (closed) {
                throw new Error('Database has been closed');
            }

            var records = [];
            for (var i = 0; i < arguments.length - 1; i++) {
                records[i] = arguments[i + 1];
            }

            var transaction = db.transaction(table, transactionModes.readwrite),
                store = transaction.objectStore(table),
                keyPath = store.keyPath,
                deferred = Deferred();

            records.forEach(function(record) {
                var req;
                if (record.item && record.key) {
                    var key = record.key;
                    record = record.item;
                    req = store.put(record, key);
                } else {
                    req = store.put(record);
                }

                req.onsuccess = function(e) {
                    deferred.notify();
                };
            });

            transaction.oncomplete = function() {
                deferred.resolve(records, that);
            };
            transaction.onerror = function(e) {
                var error = new Error();
                error.dbError = e;
                e.records = records;
                deferred.reject(error);
            };
            transaction.onabort = function(e) {
                var error = new Error();
                error.dbError = e;
                e.records = records;
                deferred.reject(error);
            };
            return deferred.promise();
        };

        this.remove = function(table, key) {
            if (closed) {
                throw new Error('Database has been closed');
            }
            var transaction = db.transaction(table, transactionModes.readwrite),
                store = transaction.objectStore(table),
                deferred = Deferred();

            var req = store.delete(key);
            transaction.oncomplete = function() {
                deferred.resolve(key);
            };
            transaction.onerror = function(e) {
                var error = new Error();
                error.dbError = e;
                deferred.reject(error);
            };
            return deferred.promise();
        };

        this.clear = function(table) {
            if (closed) {
                throw new Error('Database has been closed');
            }
            var transaction = db.transaction(table, transactionModes.readwrite),
                store = transaction.objectStore(table),
                deferred = Deferred();

            var req = store.clear();
            transaction.oncomplete = function() {
                deferred.resolve();
            };
            transaction.onerror = function(e) {
                var error = new Error();
                error.dbError = e;
                deferred.reject(error);
            };
            return deferred.promise();
        };

        this.close = function() {
            if (closed) {
                throw new Error('Database has been closed');
            }
            db.close();
            closed = true;
        };

        this.get = function(table, id) {
            if (closed) {
                throw new Error('Database has been closed');
            }
            var transaction = db.transaction(table),
                store = transaction.objectStore(table),
                deferred = Deferred();

            var req = store.get(id);
            req.onsuccess = function(e) {
                deferred.resolve(e.target.result);
            };
            transaction.onerror = function(e) {
                var error = new Error();
                error.dbError = e;
                deferred.reject(error);
            };
            return deferred.promise();
        };

        this.query = function(table, index) {
            if (closed) {
                throw new Error('Database has been closed');
            }
            return new IndexQuery(table, db, index);
        };

        for (var i = 0, il = db.objectStoreNames.length; i < il; i++) {
            (function(storeName) {
                that[storeName] = {};
                for (var i in that) {
                    if (!hasOwn.call(that, i) || i === 'close') {
                        continue;
                    }
                    that[storeName][i] = (function(i) {
                        return function() {
                            var args = [storeName].concat([].slice.call(arguments, 0));
                            return that[i].apply(that, args);
                        };
                    })(i);
                }
            })(db.objectStoreNames[i]);
        }
    };

    var IndexQuery = function(table, db, indexName) {
        var that = this;
        var modifyObj = false;
        var removeObj = false;

        var runQuery = function(type, args, cursorType, direction, limitRange, filters, mapper) {
            var transaction = db.transaction(table, modifyObj || removeObj ? transactionModes.readwrite : transactionModes.readonly),
                store = transaction.objectStore(table),
                index = indexName ? store.index(indexName) : store,
                keyRange = type ? IDBKeyRange[type].apply(null, args) : null,
                results = [],
                deferred = Deferred(),
                indexArgs = [keyRange],
                limitRange = limitRange ? limitRange : null,
                filters = filters ? filters : [],
                counter = 0;

            if (cursorType !== 'count') {
                indexArgs.push(direction || 'next');
            };

            // create a function that will set in the modifyObj properties into
            // the passed record.
            var modifyKeys = modifyObj ? Object.keys(modifyObj) : false;
            var modifyRecord = function(record) {
                for (var i = 0; i < modifyKeys.length; i++) {
                    var key = modifyKeys[i];
                    var val = modifyObj[key];
                    if (val instanceof Function) val = val(record);
                    record[key] = val;
                }
                return record;
            };

            var removeFn = (removeObj instanceof Function) ? removeObj : false;
            var removeRecord = function(record) {
                return removeFn ? removeFn(record) : false;
            };

            index[cursorType].apply(index, indexArgs).onsuccess = function(e) {
                var cursor = e.target.result;
                if (typeof cursor === typeof 0) {
                    results = cursor;
                } else if (cursor) {
                    if (limitRange !== null && limitRange[0] > counter) {
                        counter = limitRange[0];
                        cursor.advance(limitRange[0]);
                    } else if (limitRange !== null && counter >= (limitRange[0] + limitRange[1])) {
                        //out of limit range... skip
                    } else {
                        var matchFilter = true;
                        var result = 'value' in cursor ? cursor.value : cursor.key;

                        filters.forEach(function(filter) {
                            if (!filter || !filter.length) {
                                //Invalid filter do nothing
                            } else if (filter.length === 2) {
                                matchFilter = (result[filter[0]] === filter[1])
                            } else {
                                matchFilter = filter[0].apply(undefined, [result]);
                            }
                        });

                        if (matchFilter) {
                            counter++;
                            results.push(mapper(result));
                            // if we're doing a modify, run it now
                            if (modifyObj) {
                                result = modifyRecord(result);
                                cursor.update(result);
                            }

                            if (removeObj) {
                                if (removeFn(result)) {
                                    cursor.delete(result);
                                }
                            }
                        }
                        cursor.
                        continue ();
                    }
                }
            };

            transaction.oncomplete = function() {
                deferred.resolve(results);
            };
            transaction.onerror = function(e) {
                var error = new Error();
                error.dbError = e;
                deferred.reject(error);
            };
            transaction.onabort = function(e) {
                var error = new Error();
                error.dbError = e;
                deferred.reject(error);
            };
            return deferred.promise();
        };

        var Query = function(type, args) {
            var direction = 'next',
                cursorType = 'openCursor',
                filters = [],
                limitRange = null,
                mapper = defaultMapper,
                unique = false;

            var execute = function() {
                return runQuery(type, args, cursorType, unique ? direction + 'unique' : direction, limitRange, filters, mapper);
            };

            var limit = function() {
                limitRange = Array.prototype.slice.call(arguments, 0, 2)
                if (limitRange.length == 1) {
                    limitRange.unshift(0)
                }

                return {
                    execute: execute,
                    modify: modify,
                    remove: remove
                };
            };
            var count = function() {
                direction = null;
                cursorType = 'count';

                return {
                    execute: execute
                };
            };
            var keys = function() {
                cursorType = 'openKeyCursor';

                return {
                    desc: desc,
                    execute: execute,
                    filter: filter,
                    distinct: distinct,
                    map: map
                };
            };
            var filter = function() {
                filters.push(Array.prototype.slice.call(arguments, 0, 2));

                return {
                    keys: keys,
                    execute: execute,
                    filter: filter,
                    desc: desc,
                    distinct: distinct,
                    modify: modify,
                    remove: remove,
                    limit: limit,
                    map: map
                };
            };
            var desc = function() {
                direction = 'prev';

                return {
                    keys: keys,
                    execute: execute,
                    filter: filter,
                    distinct: distinct,
                    modify: modify,
                    remove: remove,
                    map: map
                };
            };
            var distinct = function() {
                unique = true;
                return {
                    keys: keys,
                    count: count,
                    execute: execute,
                    filter: filter,
                    desc: desc,
                    modify: modify,
                    remove: remove,
                    map: map
                };
            };
            var modify = function(update) {
                modifyObj = update;
                return {
                    execute: execute
                };
            };
            var remove = function(update) {
                if (typeof(update) == "undefined") {
                    removeObj = function(item) {
                        return true;
                    }
                } else {
                    removeObj = update;
                }

                return {
                    execute: execute
                };
            };
            var map = function(fn) {
                mapper = fn;

                return {
                    execute: execute,
                    count: count,
                    keys: keys,
                    filter: filter,
                    desc: desc,
                    distinct: distinct,
                    modify: modify,
                    remove: remove,
                    limit: limit,
                    map: map
                };
            };

            return {
                execute: execute,
                count: count,
                keys: keys,
                filter: filter,
                desc: desc,
                distinct: distinct,
                modify: modify,
                remove: remove,
                limit: limit,
                map: map
            };
        };

        'only bound upperBound lowerBound'.split(' ').forEach(function(name) {
            that[name] = function() {
                return new Query(name, arguments);
            };
        });

        this.filter = function() {
            var query = new Query(null, null);
            return query.filter.apply(query, arguments);
        };

        this.all = function() {
            return this.filter();
        };
    };

    var createSchema = function(e, schema, db) {
        if (typeof schema === 'function') {
            schema = schema();
        }

        for (var tableName in schema) {
            var table = schema[tableName];
            var store;
            if (!hasOwn.call(schema, tableName) || db.objectStoreNames.contains(tableName)) {
                store = e.currentTarget.transaction.objectStore(tableName);
            } else {
                store = db.createObjectStore(tableName, table.key);
            }

            for (var indexKey in table.indexes) {
                if (store.indexNames.contains(indexKey)) {
                    continue;
                }

                var index = table.indexes[indexKey];
                store.createIndex(indexKey, index.key || indexKey, Object.keys(index).length ? index : {
                    unique: false
                });
            }
        }
    };

    var open = function(e, server, version, schema) {
        var db = e.target.result;
        var s = new Server(db, server);
        var upgrade;

        var deferred = Deferred();
        deferred.resolve(s);

        return deferred.promise();
    };

    var db = {
        version: '0.9.0',
        open: function(options) {
            var request;

            var deferred = Deferred();

            request = indexedDB.open(options.server, options.version);

            request.onsuccess = function(e) {
                open(e, options.server, options.version, options.schema)
                    .done(deferred.resolve)
                    .fail(deferred.reject)
                    .progress(deferred.notify);
            };

            request.onupgradeneeded = function(e) {
                createSchema(e, options.schema, e.target.result);
            };
            request.onerror = function(e) {
                var error = new Error();
                error.dbError = e;
                deferred.reject(error);
            };


            return deferred.promise();
        }
    };

    return db;
});
define('dataLayer/indexedDBBacking',["class", "helpers", "db", "event"], function(Class, Helpers, db, Event) {
  var instance = Class.extend({
    _parent: null,

    _fileInfoPromise: null,
    _fileServerPromise: null,

    init: function(parent) {
      this._parent = parent;
    },

    load: function(fileId) {
      this._fileServerPromise = Promise.cast(
        db.open({
          server: fileId,
          version: 2,
          schema: {
            localActions: {
              key: {
                keyPath: 'id'
              }
            },
            remoteActions: {
              key: {
                keyPath: 'id'
              },
              indexes: {
                id: {
                  unique: true
                },
                index: {
                  unique: true
                }
              }
            }
          }
        }));

      this._fileInfoPromise = this._parent.getFileInfo(fileId);

      return Promise.all([this._fileServerPromise, this._fileInfoPromise])
        .then(function(results) {
          return results[1]
        });
    },

    create: function(file) {
      return this._parent._addFile(file)
        .then((function() {
          return this.load(file.id);
        }).bind(this));
    },

    getActions: function() {
      return this._fileServerPromise.then((function(server) {

        var localPromise = Promise.cast(
          server.localActions.query()
          .all()
          .execute()
        );

        var remotePromise = Promise.cast(
          server.remoteActions.query('index')
          .all()
          .execute()
        );

        return Promise.all([localPromise, remotePromise])
          .then(function(results) {
            return {
              local: results[0],
              remote: results[1],
            };
          });
      }).bind(this));
    },

    rename: function(newName) {
      return this._fileInfoPromise.then((function(fileInfo) {
        return this._parent._renameFile(fileInfo.id, newName)
          .then(function(newFile) {
            this._fileInfoPromise = Promise.cast(newFile);
          });
      }).bind(this));
    },

    updateThumbnail: function(dataURL) {
      return this._fileInfoPromise.then((function(fileInfo) {
        return this._parent._updateThumbnail(fileInfo.id, dataURL);
      }).bind(this));
    },

    addLocalAction: function(action) {
      return this._fileServerPromise.then((function(server) {
        return Promise.cast(server.localActions.add(action));
      }).bind(this));
    },

    removeLocalAction: function(actionId) {
      return this._fileServerPromise.then((function(server) {
        return Promise.cast(server.localActions.remove(actionId));
      }).bind(this));
    },

    addRemoteActions: function(index, actions) {
      return this._fileServerPromise.then((function(server) {
        return Promise.cast(server.remoteActions
          .query('index')
          .lowerBound(index)
          .desc()
          .modify({
            index: function(action) {
              return action.index + actions.length;
            }
          })
          .execute()
        )
          .then(function() {
            return Promise.cast(server.remoteActions.add.apply(server.remoteActions, actions))
          })
      }).bind(this));
    },

    removeRemoteActions: function(index, length) {

      return this._fileServerPromise.then((function(server) {
        return Promise.cast(server.remoteActions
          .query('index')
          .lowerBound(index)
          .limit(length)
          .remove()
          .execute()
        )
          .then(function() {
            return Promise.cast(server
              .remoteActions
              .query('index')
              .lowerBound(index)
              .modify({
                index: function(action) {
                  return action.index - length;
                }
              })
              .execute())
          });
      }).bind(this));
    },

    replaceFileId: function(newId) {
      return this._fileInfoPromise.then((function(fileInfo) {

        var oldActionsPromise = this.getActions();

        var oldId = fileInfo.id;
        fileInfo.id = newId;
        var newFile = fileInfo;

        this._fileInfoPromise = Promise.cast(fileInfo);

        return Promise.all([oldActionsPromise, this._fileInfoPromise])
          .then((function(results) {
            var oldActions = results[0];
            var newInfo = results[1];

            return this._parent._addFile(newInfo)
              .then((function(newFile) {
                return this.load(newFile[0].id);
              }).bind(this))
              .then((function() {
                return this._copyAllActions(oldActions);
              }).bind(this))
              .then((function() {
                return this._parent.deleteFile(oldId);
              }).bind(this))
              .then(function() {
                return newInfo;
              });
          }).bind(this))
      }).bind(this));
    },

    close: function() {
      return this._fileServerPromise.then((function(server) {
        this._fileServerPromise = Promise.reject(new Error("File Server has been closed"));
        this._fileInfoPromise = Promise.reject(new Error("File has been closed"));
        return server.close();
      }).bind(this));
    },

    updateLocalModifiedTime: function(time) {
      return this._fileInfoPromise
        .then((function(fileInfo) {
          fileInfo.localModifiedTime = time;
          this._fileInfoPromise = Promise.resolve(fileInfo);
          return this._parent._updateLocalModifiedTime(fileInfo.id, time);
        }).bind(this));
    },

    updateDriveModifiedTime: function(time) {
      return this._fileInfoPromise
        .then((function(fileInfo) {
          fileInfo.driveModifiedTime = time;
          this._fileInfoPromise = Promise.resolve(fileInfo);
          return this._parent._updateDriveModifiedTime(fileInfo.id, time);
        }).bind(this));
    },

    _copyAllActions: function(oldActions) {
      return this._fileServerPromise.then(function(server) {
        return Promise.all(
          [
            Promise.cast(server.localActions.add.apply(server, oldActions.local)),
            Promise.cast(server.remoteActions.add.apply(server, oldActions.remote)),
          ])
          .
        catch (function(error) {
          console.error("Failed copying actions", error, error.stack, error.message);
        });
      });
    },
  });

  var IndexedDBBacking = Class.extend({
    readyPromise: null,

    _serverName: null,

    init: function(serverName) {
      this._serverName = serverName ? serverName : "draw";

      this.readyPromise = Promise.cast(db.open({
        server: this._serverName,
        version: 2,
        schema: {
          files: {
            key: {
              keyPath: 'id',
            },
            indexes: {
              id: {
                unique: true
              },
              localModifiedTime: {},
            }
          }
        }
      }));
    },

    fileExists: function(fileId) {
      return this.readyPromise.then((function(server) {
        return Promise.cast(server.files.query('id')
          .only(fileId)
          .count()
          .execute()
        )
          .then((function(count) {
            return count !== 0;
          }).bind(this));
      }).bind(this));
    },

    getFiles: function() {
      return this.readyPromise.then((function(server) {
        return Promise.cast(server.files.query('localModifiedTime')
          .all()
          .filter(function(file) {
            return !file.deleted;
          })
          .desc()
          .execute()
        )
          .then((function(results) {
            return results.map(this._cleanFields);
          }).bind(this));
      }).bind(this))
    },

    _addFile: function(file) {
      return this.readyPromise.then(function(server) {
        return Promise.cast(
          server.files.add(file)
        );
      });
    },

    _renameFile: function(fileId, newName) {
      return this.readyPromise.then((function(server) {

        return Promise.cast(server.files.query('id')
          .only(fileId)
          .modify({
            name: newName
          })
          .execute()
        )
          .then((function(results) {
            return results;
          }).bind(this));
      }).bind(this));
    },

    _updateThumbnail: function(fileId, dataURL) {
      return this.readyPromise.then((function(server) {
        return Promise.cast(server.files.query('id')
          .only(fileId)
          .modify({
            thumbnail: dataURL
          })
          .execute()
        )
          .then((function(results) {
            return results;
          }).bind(this));
      }).bind(this));
    },

    getDeletedFiles: function() {
      return this.readyPromise.then((function(server) {
        return Promise.cast(server.files.query()
          .filter(function(file) {
            return file.deleted;
          })
          .execute()
        )
          .then((function(results) {
            return results.map(this._cleanFields);
          }).bind(this));
      }).bind(this));
    },

    markFileAsDeleted: function(fileId) {
      return this.readyPromise.then(function(server) {

        return Promise.cast(server.files.query('id')
          .only(fileId)
          .modify({
            deleted: true
          })
          .execute()
        )
      });
    },

    unmarkFileAsDeleted: function(fileId) {
      return this.readyPromise.then(function(server) {
        return Promise.cast(server.files.query('id')
          .only(fileId)
          .modify({
            deleted: false
          })
          .execute()
        )
          .then(function(results) {

            Event.trigger("fileAdded", results[0]);
            return results;
          });
      });
    },

    deleteFile: function(fileId) {
      return this.readyPromise.then(function(server) {

        return Promise.cast(server.files.query('id')
          .only(fileId)
          .remove()
          .execute()
        )
          .then(function(results) {
            indexedDB.deleteDatabase(fileId);

            return results;
          });
      });
    },

    getFileInfo: function(fileId) {
      return this.readyPromise.then(function(server) {
        return Promise.cast(server.files.query('id')
          .only(fileId)
          .execute()
        ).then(function(results) {
          if (results.length == 0) {
            return undefined;
          }
          return results[0];
        });
      }).then((function(result) {
        if (result) {
          this._cleanFields(result)
        }

        return result;
      }).bind(this));;
    },

    _updateLocalModifiedTime: function(fileId, time) {
      return this.readyPromise.then(function(server) {
        return Promise.cast(server.files.query('id')
          .only(fileId)
          .modify({
            localModifiedTime: time
          })
          .execute()
        );
      });
    },

    _updateDriveModifiedTime: function(fileId, time) {
      return this.readyPromise.then(function(server) {
        return Promise.cast(server.files.query('id')
          .only(fileId)
          .modify({
            driveModifiedTime: time
          })
          .execute()
        );
      });
    },

    clearAll: function() {
      return Promise.all([this.getFiles(), this.getDeletedFiles()])
        .then((function(results) {
          return results[0].concat(results[1]);
        }).bind(this))
        .then((function(files) {
          files.map((function(file) {
            return this.deleteFile(file.id);
          }).bind(this))

          return Promise.all(files).then((function() {
            indexedDB.deleteDatabase(this._serverName);
          }).bind(this));
        }).bind(this))
    },

    _cleanFields: function(fileInfo) {
      if (fileInfo.deleted) {
        delete fileInfo.deleted;
      }

      return fileInfo;
    },

    instance: instance,
  });

  return IndexedDBBacking;
});
define('dataLayer/webSQLBacking',["class", "helpers", "event"], function(Class, Helpers, Event) {
  var instance = Class.extend({
    _parent: null,

    _fileId: null,

    init: function(parent) {
      this._parent = parent;
    },

    load: function(fileId) {
      this._fileId = fileId;

      return this._parent.getFileInfo(fileId);
    },

    create: function(file) {
      return this._parent._addFile(file)
        .then((function() {
          return this.load(file.id);
        }).bind(this));
    },

    getActions: function() {
      return this._parent.readyPromise.then((function(server) {
        return new Promise((function(overallResolve, overallReject) {

          server.readTransaction((function(tx) {
            var promises = [];

            promises.push(new Promise((function(resolve, reject) {
              tx.executeSql('SELECT * FROM `F' + this._fileId + '-local`', [], (function(transaction, results) {
                  var resultsObj = this._parent._convertResultToObject(results, ["value"]);
                  resolve(resultsObj);
                }).bind(this),
                function(transaction, error) {
                  reject(error);
                });
            }).bind(this)));

            promises.push(new Promise((function(resolve, reject) {
              tx.executeSql('SELECT * FROM `F' + this._fileId + '-remote` ORDER BY `index`', [], (function(transaction, results) {
                  var resultsObj = this._parent._convertResultToObject(results, ["value"]);
                  resolve(resultsObj);
                }).bind(this),
                function(transaction, error) {
                  reject(error);
                });
            }).bind(this)));

            Promise.all(promises).then(function(results) {
              overallResolve({
                local: results[0],
                remote: results[1],
              });
            })
              .
            catch (function(error) {
              overallReject(error);
            });

          }).bind(this));

        }).bind(this));
      }).bind(this));
    },

    rename: function(newName) {
      return this._parent._renameFile(this._fileId, newName);
    },

    updateThumbnail: function(dataURL) {
      return this._parent._updateThumbnail(this._fileId, dataURL);
    },

    addLocalAction: function(action) {
      return this._parent.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('INSERT INTO `F' + this._fileId + '-local` (id, type, value) VALUES (?, ?, ?)', [action.id, action.type, JSON.stringify(action.value)], (function(transaction, results) {
                var resultsObj = this._parent._convertResultToObject(results, ["value"]);
                resolve(resultsObj[0]);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    removeLocalAction: function(actionId) {
      return this._parent.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('DELETE FROM `F' + this._fileId + '-local` WHERE id = ?', [actionId], (function(transaction, results) {
                var resultsObj = this._parent._convertResultToObject(results, ["value"]);
                resolve(resultsObj[0]);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    addRemoteActions: function(index, actions) {
      return this._parent.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('UPDATE `F' + this._fileId + '-remote` SET `index` = `index` + ? WHERE `index` >= ?', [actions.length, index], (function(transaction, results) {
                var promises = [];

                actions.forEach((function(action) {
                  promises.push(new Promise((function(resolve, reject) {
                    tx.executeSql('INSERT INTO `F' + this._fileId + '-remote` (id, `index`, type, value) VALUES (?, ?, ?, ?)', [action.id, action.index, action.type, JSON.stringify(action.value)],
                      function(transaction, results) {
                        resolve(results);
                      },
                      function(transaction, error) {
                        reject(error);
                      })
                  }).bind(this)));
                }).bind(this));

                Promise.all(promises).then(function(results) {
                  resolve(results);
                })
                  .
                catch (function(error) {
                  reject(error);
                });
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });

          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    removeRemoteActions: function(index, length) {
      return this._parent.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('DELETE FROM `F' + this._fileId + '-remote` WHERE `index` between ? and ?', [index, index + length - 1], (function(transaction, results) {
                tx.executeSql('UPDATE `F' + this._fileId + '-remote` SET `index` = `index` - ? WHERE `index` >= ?', [length, index],
                  function(transaction, results) {
                    resolve(results);
                  },
                  function(transaction, error) {
                    reject(error);
                  });
              }).bind(this),
              function(transaction, error) {
                reject(error);
              }
            );
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    replaceFileId: function(newId) {
      return this._parent._replaceFileId(this._fileId, newId)
        .then((function() {
          this._fileId = newId;
        }).bind(this)).
      catch (function(error) {
        console.error("Error replacing fileId", error);
        throw error;
      });
    },

    close: function() {
      this._fileId = null;

      return Promise.resolve();
    },

    updateLocalModifiedTime: function(time) {
      return this._parent._updateLocalModifiedTime(this._fileId, time);
    },

    updateDriveModifiedTime: function(time) {
      return this._parent._updateDriveModifiedTime(this._fileId, time);
    },
  });

  var WebSQLBacking = Class.extend({
    FIELDS: "id, name, localModifiedTime, driveModifiedTime, thumbnail",

    readyPromise: null,

    _serverName: null,

    init: function(serverName) {
      this._serverName = serverName ? serverName : "files";
      var server = openDatabase("draw", "", "draw", 4 * 1024 * 1024);
      this.readyPromise = Promise.resolve(server)
        .then((function(server) {
          return new Promise((function(resolve, reject) {
            server.transaction((function(tx) {
              tx.executeSql('CREATE TABLE IF NOT EXISTS `' + this._serverName + '`' +
                '(' +
                'id VARCHAR(255) PRIMARY KEY,' +
                'name VARCHAR(255),' +
                'localModifiedTime INTEGER,' +
                'driveModifiedTime VARCHAR(255),' +
                'thumbnail TEXT,' +
                'deleted BOOL' +
                ')', [],
                function() {
                  resolve(server)
                },
                function(transaction, error) {
                  reject(error);
                });
            }).bind(this));
          }).bind(this))
            .then((function() {
              // do sql migrations
              var sequence = Promise.resolve();

              if (server.version == "1.0") {
                sequence = sequence.then((function() {
                  return new Promise((function(resolve, reject) {
                    server.changeVersion(server.version, "2", (function(tx) {
                        tx.executeSql('DROP TABLE IF EXISTS `files`', [],
                          function() {
                            resolve()
                          },
                          function(transaction, error) {
                            reject(error);
                          })
                      }).bind(this),
                      function(error) {
                        reject(error);
                      })
                  }).bind(this))
                    .then(function() {
                      // just reload and start fresh
                      location.reload();
                    });
                }).bind(this))
              }

              return sequence;
            }).bind(this))
        }).bind(this))
        .then(function() {
          return server;
        })
        .
      catch (function(error) {
        console.error("Error initializing database", error);
        throw error;
      });
    },

    fileExists: function(fileId) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('SELECT COUNT(*) AS count FROM `' + this._serverName + '` WHERE id = ?', [fileId], (function(transaction, results) {
                resolve(results.rows.item(0).count !== 0);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },


    getFiles: function() {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {

          server.readTransaction((function(tx) {
            tx.executeSql("SELECT " + this.FIELDS + " FROM `" + this._serverName + "` WHERE `deleted`='false' ORDER BY localModifiedTime DESC", [], (function(transaction, results) {
                var resultsObj = this._convertResultToObject(results);
                resolve(resultsObj);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },



    _addFile: function(file) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(overallResolve, overallReject) {

          server.transaction((function(tx) {
            var promises = [];
            promises.push(new Promise((function(resolve, reject) {
              tx.executeSql('INSERT INTO `' + this._serverName + '` VALUES (?, ?, ?, ?, ?, ?)', [file.id, file.name, file.localModifiedTime, file.driveModifiedTime, file.thumbnail, false],
                function(transaction, results) {
                  resolve(results);
                },
                function(transaction, error) {
                  reject(error);
                });
            }).bind(this)));

            promises.push(new Promise((function(resolve, reject) {
              tx.executeSql('CREATE TABLE IF NOT EXISTS `F' + file.id + '-local` ' +
                '(id VARCHAR(255) PRIMARY KEY, type VARCHAR(255), value TEXT)', [],
                function(transaction, results) {
                  resolve(results);
                },
                function(transaction, error) {
                  reject(error);
                });
            }).bind(this)));

            promises.push(new Promise((function(resolve, reject) {
              tx.executeSql('CREATE TABLE IF NOT EXISTS `F' + file.id + '-remote` ' +
                '(id VARCHAR(255) PRIMARY KEY, `index` INTEGER, type VARCHAR(255), value TEXT)', [],
                function(transaction, results) {
                  resolve(results);
                },
                function(transaction, error) {
                  reject(error);
                });
            }).bind(this)));

            Promise.all(promises)
              .then(function(results) {
                overallResolve();
              })
              .
            catch (function(error) {
              overallReject(error);
            })
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    _renameFile: function(fileId, newName) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('UPDATE `' + this._serverName + '` SET name = ? WHERE id = ?', [newName, fileId], (function(transaction, results) {
                var resultsObj = this._convertResultToObject(results);
                resolve(resultsObj[0]);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    _updateThumbnail: function(fileId, dataURL) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('UPDATE `' + this._serverName + '` SET thumbnail = ? WHERE id = ?', [dataURL, fileId], (function(transaction, results) {
                var resultsObj = this._convertResultToObject(results);
                resolve(resultsObj[0]);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    _replaceFileId: function(fileId, newId) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            var promises = [];
            promises.push(new Promise((function(resolve, reject) {
              tx.executeSql('UPDATE `' + this._serverName + '` SET id = ? WHERE id = ?', [newId, fileId], (function(transaction, results) {
                  var resultsObj = this._convertResultToObject(results);
                  resolve(resultsObj[0]);
                }).bind(this),
                function(transaction, error) {
                  reject(error);
                });
            }).bind(this)));

            promises.push(new Promise(function(resolve, reject) {
              tx.executeSql('ALTER TABLE `F' + fileId + '-local` RENAME TO `F' + newId + '-local`', [],
                function(transaction, results) {
                  resolve(results);
                },
                function(transaction, error) {
                  reject(error);
                });
            }));

            promises.push(new Promise(function(resolve, reject) {
              tx.executeSql('ALTER TABLE `F' + fileId + '-remote` RENAME TO `F' + newId + '-remote`', [],
                function(transaction, results) {
                  resolve(results);
                },
                function(transaction, error) {
                  reject(error);
                });
            }));

            Promise.all(promises)
              .then(function(results) {
                resolve(results[0]);
              })
              .
            catch (function(error) {
              reject(error);
            })
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    getDeletedFiles: function(callback) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.readTransaction((function(tx) {
            tx.executeSql("SELECT " + this.FIELDS + " FROM `" + this._serverName + "` WHERE `deleted`='true' ORDER BY localModifiedTime DESC", [], (function(transaction, results) {
                var resultsObj = this._convertResultToObject(results);
                resolve(resultsObj);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    markFileAsDeleted: function(fileId) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('UPDATE `' + this._serverName + '` SET deleted = ? WHERE id = ?', [true, fileId], (function(transaction, results) {
                var resultsObj = this._convertResultToObject(results);
                resolve(resultsObj[0]);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    unmarkFileAsDeleted: function(fileId) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('UPDATE `' + this._serverName + '` SET deleted = ? WHERE id = ?', [false, fileId], (function(transaction, results) {
                var resultsObj = this._convertResultToObject(results);
                resolve(resultsObj[0]);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    deleteFile: function(fileId) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            var promises = [];
            promises.push(new Promise((function(resolve, reject) {
              tx.executeSql('DELETE FROM `' + this._serverName + '` WHERE id = ?', [fileId], (function(transaction, results) {
                  var resultsObj = this._convertResultToObject(results);
                  resolve(resultsObj[0]);
                }).bind(this),
                function(transaction, error) {
                  reject(error);
                });
            }).bind(this)));

            promises.push(new Promise(function(resolve, reject) {
              tx.executeSql('DROP TABLE IF EXISTS `F' + fileId + '-local`', [], (function(transaction, results) {
                  resolve();
                }).bind(this),
                function(transaction, error) {
                  reject(error);
                });
            }));

            promises.push(new Promise(function(resolve, reject) {
              tx.executeSql('DROP TABLE IF EXISTS `F' + fileId + '-remote`', [], (function(transaction, results) {
                  resolve();
                }).bind(this),
                function(transaction, error) {
                  reject(error);
                });
            }));

            Promise.all(promises)
              .then(function(results) {
                resolve(results[0]);
              })
              .
            catch (function(error) {
              reject(error);
            })
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    getFileInfo: function(fileId) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.readTransaction((function(tx) {
            tx.executeSql('SELECT ' + this.FIELDS + ' FROM `' + this._serverName + '` WHERE id = ?', [fileId], (function(transaction, results) {
                var resultsObj = this._convertResultToObject(results);
                resolve(resultsObj[0]);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    _updateLocalModifiedTime: function(fileId, time) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('UPDATE `' + this._serverName + '` SET localModifiedTime = ? WHERE id = ?', [time, fileId], (function(transaction, results) {
                var resultsObj = this._convertResultToObject(results);
                resolve(resultsObj[0]);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    _updateDriveModifiedTime: function(fileId, time) {
      return this.readyPromise.then((function(server) {
        return new Promise((function(resolve, reject) {
          server.transaction((function(tx) {
            tx.executeSql('UPDATE `' + this._serverName + '` SET driveModifiedTime = ? WHERE id = ?', [time, fileId], (function(transaction, results) {
                var resultsObj = this._convertResultToObject(results);
                resolve(resultsObj[0]);
              }).bind(this),
              function(transaction, error) {
                reject(error);
              });
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    // JSON Decode should be an array of columns that have JSON that should be parsed
    _convertResultToObject: function(results, JSONDecode) {
      var rows = results.rows;
      var objArray = new Array(rows.length);

      for (var i = 0; i < rows.length; i++) {
        var item = rows.item(i);
        objArray[i] = Helpers.clone(item);

        if (JSONDecode) {
          for (var j = 0; j < JSONDecode.length; j++) {
            // If this key exists on the object
            var value = objArray[i][JSONDecode[j]];
            if (value) {
              // Replace it with a JSON Parsed version
              var obj = JSON.parse(value);
              objArray[i][JSONDecode[j]] = obj;
            }
          }
        }

      }

      return objArray;
    },

    clearAll: function() {
      return Promise.all([this.getFiles(), this.getDeletedFiles()])
        .then((function(results) {
          return results[0].concat(results[1]);
        }).bind(this))
        .then((function(files) {
          files.map((function(file) {
            return this.deleteFile(file.id);
          }).bind(this))

          return Promise.all(files).then((function() {
            return this.readyPromise;
          }).bind(this))
            .then((function(server) {
              return new Promise((function(resolve, reject) {
                server.transaction((function(tx) {
                  tx.executeSql('DROP TABLE `' + this._serverName + '`', [], (function(transaction, results) {
                      resolve();
                    }).bind(this),
                    function(transaction, error) {
                      reject(error);
                    });
                }).bind(this));
              }).bind(this));
            }).bind(this));
        }).bind(this))
    },

    instance: instance,
  });

  return WebSQLBacking;
});
define('dataLayer/driveBacking',["class", "helpers", "gauth"], function(Class, Helpers, GAuth) {
  var instance = Class.extend({
    _parent: null,

    _docPromise: null,

    _addedCallback: null,
    _removedCallback: null,

    // Delay if we need to change the file modified time of a file
    _updateFileTimeout: null,

    init: function(parent) {
      this._parent = parent;

      this._actionsAdded = this._actionsAdded.bind(this);
      this._actionsRemoved = this._actionsRemoved.bind(this);
      this._saveStateChanged = this._saveStateChanged.bind(this);
    },

    listen: function(addedCallback, removedCallback) {
      this._addedCallback = addedCallback;
      this._removedCallback = removedCallback;
    },

    stopListening: function() {
      this._addedCallback = null;
      this._removedCallback = null;
    },

    load: function(fileId) {
      return this._parent._open(fileId)
        .then((function(fileInfo) {
          return this._openForRealtime(fileInfo.id);
        }).bind(this))
        .
      catch (function(error) {
        console.error(error, error.stack, error.message);
      });
    },

    create: function(file) {
      return this._parent._add(file)
        .then((function(fileInfo) {
          return this._openForRealtime(fileInfo.id)
            .then(function() {
              return fileInfo;
            })
        }).bind(this))
        .
      catch (function(error) {
        console.error(error, error.stack, error.message);
      });
    },

    _openForRealtime: function(fileId) {
      return new Promise((function(resolve, reject) {

        gapi.drive.realtime.load(fileId, (function(doc) {
            // file was loaded
            this._docPromise = Promise.resolve(doc);

            this._docPromise.then((function(doc) {
              var actions = doc.getModel().getRoot().get('actions');
              actions.addEventListener(gapi.drive.realtime.EventType.VALUES_ADDED, this._actionsAdded);
              actions.addEventListener(gapi.drive.realtime.EventType.VALUES_REMOVED, this._actionsRemoved);

              doc.addEventListener(gapi.drive.realtime.EventType.DOCUMENT_SAVE_STATE_CHANGED, this._saveStateChanged);

              resolve(this._docPromise);
            }).bind(this));
          }).bind(this),
          function(model) {
            // file was created
            var actions = model.createList();
            var root = model.getRoot();
            root.set('title', 'Untitled File');
            root.set('actions', actions);
            root.set('id', fileId);
          },
          function(error) {

            if (error.type == gapi.drive.realtime.ErrorType.TOKEN_REFRESH_REQUIRED) {
              console.warn("Token expired, reauthorizing");
              GAuth.authorize();
              return;
              //reject(error);
            } else if (error.type == gapi.drive.realtime.ErrorType.CLIENT_ERROR) {
              //reject(new Error(error));
            } else if (error.type == gapi.drive.realtime.ErrorType.NOT_FOUND) {
              //reject(new Error(error));
              //alert("The file was not found. It does not exist or you do not have read access to the file.");
            }

            var error = new Error();
            error.object = error;
            reject(error);
          }
        );
      }).bind(this));
    },

    _actionsAdded: function(e) {
      if (this._addedCallback) {
        this._addedCallback(e);
      }
    },

    _actionsRemoved: function(e) {
      if (this._removedCallback) {
        this._removedCallback(e);
      }
    },

    _saveStateChanged: function(e) {
      if (this._updateFileTimeout) {

        // Clear it and set a new one
        clearTimeout(this._updateFileTimeout);
      }

      // one second delay
      this._updateFileTimeout = setTimeout((function() {
        this._docPromise.then((function(doc) {
          this._parent.touchFile(doc.getModel().getRoot().get('id'))
            .then(function(result) {
              console.log("Touched file", result);
            })
            .
          catch (function(e) {
            console.error("Error touching file", e);
          });
        }).bind(this));
      }).bind(this), 2000);
    },

    getActions: function() {
      return this._docPromise.then(function(doc) {
        return doc.getModel().getRoot().get('actions').asArray();
      });
    },

    rename: function(newName) {
      return this._docPromise.then((function(doc) {
        doc.getModel().getRoot().set("title", newName);
        return this._parent._renameFile(doc.getModel().getRoot().get('id'), newName)
      }).bind(this));
    },

    addAction: function(action) {
      return this._docPromise.then(function(doc) {
        var actions = doc.getModel().getRoot().get('actions');
        actions.insert(actions.length, action);
      });
    },

    removeAction: function(actionIndex) {
      return this._docPromise.then(function(doc) {
        var actions = doc.getModel().getRoot().get('actions');
        actions.remove(actionIndex);
      });
    },

    undo: function() {
      return this._docPromise.then(function(doc) {
        doc.getModel().undo();
      });
    },

    redo: function() {
      return this._docPromise.then(function(doc) {
        doc.getModel().redo();
      });
    },

    close: function() {
      if (!this._docPromise) {
        debugger;
      }

      return this._docPromise.then(function(doc) {
        doc.close();
      });
    },
  });

  var DriveBacking = Class.extend({
    _appId: 450627732299,
    _key: 'AIzaSyAOU0dwrVt0XNvGibqE93ATS2X1bMP5pAI',
    REALTIME_MIMETYPE: 'application/vnd.google-apps.drive-sdk',
    APP_MIMETYPE: null,
    _fields: 'id,modifiedDate,shared,title,userPermission(role)',

    init: function() {
      this.APP_MIMETYPE = this.REALTIME_MIMETYPE+"."+this._appId;
    },

    getFiles: function() {
      return new Promise((function(resolve, reject) {
        gapi.client.load('drive', 'v2', (function() {
          gapi.client.drive.files.list({
            'q': "trashed=false and mimeType='" + this.APP_MIMETYPE + "'",
            'fields': 'items(' + this._fields + ')',
          }).execute(function(resp) {
            if (!resp) {
              resolve([]);
              return;
            }

            if (resp.error) {
              var error = new Error();
              error.object = resp;
              reject(error);

            } else {
              resolve(resp.items);
            }
          });
        }).bind(this));
      }).bind(this));
    },

    getFileInfo: function(fileId) {
      return new Promise((function(resolve, reject) {
        gapi.client.load('drive', 'v2', (function() {
          var request = gapi.client.drive.files.get({
            'fileId': fileId,
            'fields': this._fields+",owners(displayName,picture)",
            'key': this._key,
          }).execute((function(resp) {
            if (resp.error) {
              var error = new Error();
              error.object = resp;
              reject(error);
            } else {
              resolve(resp);
            }
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    canReadFile: function(fileId) {
      return new Promise((function(resolve, reject) {
        gapi.client.load('drive', 'v2', (function() {
          var request = gapi.client.drive.files.get({
            'fileId': fileId,
            'fields': 'mimeType',
            'key': this._key,
          }).execute((function(resp) {
            if (resp.error) {
              resolve(false);
            } else {
              if (resp.mimeType == this.APP_MIMETYPE) {
                resolve(true);
              }
              else
              {
                resolve(false);
              }
            }
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    _open: function(fileId) {
      return new Promise((function(resolve, reject) {
        gapi.client.load('drive', 'v2', (function() {
          var request = gapi.client.drive.files.get({
            'fileId': fileId,
            'fields': this._fields,
          }).execute((function(resp) {

            if (resp.error) {
              var error = new Error();
              error.object = resp;
              reject(error);
            } else {
              resolve({
                id: resp.id,
              });
            }
          }).bind(this));
        }).bind(this));
      }).bind(this));
    },

    _add: function(file) {
      return new Promise((function(resolve, reject) {
        gapi.client.load('drive', 'v2', (function() {
          gapi.client.drive.files.insert({
            'resource': {
              mimeType: this.REALTIME_MIMETYPE,
              title: file.name,
            },
            'fields': this._fields
          }).execute(function(resp) {
            if (resp.error) {
              var error = new Error();
              error.object = resp;
              reject(error);
            } else {
              resolve({
                id: resp.id,
              });
            }
          });
        }).bind(this));
      }).bind(this));
    },

    _renameFile: function(fileId, newName) {
      return new Promise((function(resolve, reject) {

        var body = {
          'title': newName
        };

        gapi.client.load('drive', 'v2', (function() {
          var request = gapi.client.drive.files.patch({
            'fileId': fileId,
            'resource': body,
            'fields': this._fields,
          });
          request.execute(function(resp) {
            if (resp.error) {
              var error = new Error();
              error.object = resp;
              reject(error);
            } else {
              resolve(resp);
            }
          });
        }).bind(this));
      }).bind(this));
    },

    deleteFile: function(fileId) {
      return new Promise((function(resolve, reject) {

        gapi.client.load('drive', 'v2', (function() {
          var request = gapi.client.drive.files.trash({
            'fileId': fileId,
            'fields': this._fields,
          }).execute(function(resp) {
            if (resp.error) {
              var error = new Error();
              error.object = resp;
              reject(error);
            } else {
              resolve(resp);
            }
          });
        }).bind(this));
      }).bind(this));
    },

    touchFile: function(fileId) {
      return new Promise((function(resolve, reject) {
        gapi.client.load('drive', 'v2', (function() {
          var request = gapi.client.drive.files.touch({
            'fileId': fileId,
            'fields': this._fields,
          }).execute(function(resp) {
            if (resp.error) {
              var error = new Error();
              error.object = resp;
              reject(error);
            } else {
              resolve(resp);
            }
          });
        }).bind(this));
      }).bind(this));
    },

    instance: instance,
  });

  return DriveBacking;
});
define('data',["dataLayer/data", "event", "dataLayer/indexedDBBacking", "dataLayer/webSQLBacking", "dataLayer/driveBacking"], function(Data, Event, IndexedDBBacking, WebSQLBacking, DriveBacking) {
  var backing;

  if (window.indexedDB) {
   backing = new IndexedDBBacking();
  } else {
    backing = new WebSQLBacking();
  }

  var driveBacking = new DriveBacking();
  var data = new Data(backing, driveBacking);

  Event.addListener("authenticatedStatusChanged", function(status) {
    if (status.authenticated) {
      console.log("Syncing open files");
      data.syncOpenFiles();
    }
  });

  return data;
});
define('migrate',["data"], function(Data) {
  var Migrate = function Migrate() {
    this.init();
  };

  Migrate.prototype = {
    init: function() {},

    run: function() {
      //debugger;
      var version = localStorage.dataVersion;

      var sequence = Promise.resolve();

      if (!version) {
        // no version, just clear everything
        sequence = sequence.then((function() {
          //return Data.clearLocal()
        }).bind(this))
        .then(function() {
          //localStorage.dataVersion = 1;  
        });
      }

      return sequence;
    }
  }

  return new Migrate();
});
define('section',["class"], function(Class) {

	var Section = Class.extend({
		id: null,
		element: null,
		_visible: null,

		init: function() {
			if (this.id) {
				this.element = document.getElementById(this.id);
			}

			this._visible = false;
		},

		setElement: function(element) {
			this.element = element;
		},

		show: null,
		hide: null,

		afterShow: function() {
			this.element.style.display = "block";
			this._visible = true;
		},

		afterHide: function() {
			this.element.style.display = "";
			this._visible = false;
		}

	});

	return Section;
});
define('tapHandler',[], function() {
  function TapHandler(element, options) {
    this.init(element, options);
  }

  TapHandler.prototype = {
    _element: null,
    _options: null,

    _distCutoff: 20,
    _timeCutoff: 500,

    // touch or mouse
    _startType: null,
    _startTouchId: null,
    _startTime: null,
    _startX: null,
    _startY: null,

    // _startScale: null,

    _lastX: null,
    _lastY: null,

    // _lastScale: null,

    // Object with x and why of where the element is on the page
    _offset: null,

    // _inTouch: false,
    _inGesture: false,

    _ignoreGestures: false,

    init: function(element, options) {
      this._element = element;
      this._options = options;

      // Replace with binded events
      this._mouseDown = this._mouseDown.bind(this);
      this._touchDown = this._touchDown.bind(this);

      this._mouseMove = this._mouseMove.bind(this);
      this._touchMove = this._touchMove.bind(this);

      this._mouseUp = this._mouseUp.bind(this);
      this._touchUp = this._touchUp.bind(this);


      this._down = this._down.bind(this);
      this._move = this._move.bind(this);
      this._end = this._end.bind(this);
      this._gestureStart = this._gestureStart.bind(this);
      this._gestureChange = this._gestureChange.bind(this);
      this._gestureEnd = this._gestureEnd.bind(this);

      this._offset = {
        x: element.offsetLeft,
        y: element.offsetTop
      };

      this._element.addEventListener("mousedown", this._mouseDown);
      this._element.addEventListener("touchstart", this._touchDown);
      // this._element.addEventListener("gesturestart", this._gestureStart);
    },

    ignoreGestures: function(value) {
      this._ignoreGestures = value;
    },

    _calculateMouseXY: function(e) {
      e.x = e.clientX;
      e.y = e.clientY;
    },

    _calculateTouchXY: function(e) {
      var index = this._indexOfTouch(e, this._startTouchId);

      e.x = e.touches[index].clientX;
      e.y = e.touches[index].clientY;
    },

    _calculateGestureXY: function(e) {
      // use the first two touches
      e.x = (e.touches[0].clientX + e.touches[1].clientX) / 2;
      e.y = (e.touches[0].clientY + e.touches[1].clientY) / 2;
    },

    _mouseDown: function(e) {
      this._startType = "mouse";

      this._calculateMouseXY(e);
      this._down(e);

      document.addEventListener("mousemove", this._mouseMove);
      document.addEventListener("mouseup", this._mouseUp);
    },

    _touchDown: function(e) {
      this._startType = "touch";

      // If we have no startId, this is our first touch, set it
      if (this._startTouchId === null) {
        this._startTouchId = e.touches[e.touches.length - 1].identifier;
      }

      if (e.touches.length >= 2 && !this._ignoreGestures) {
        this._gestureStart(e);
      } else {
        this._calculateTouchXY(e);
        this._down(e);
      }

      document.addEventListener("touchmove", this._touchMove);
      document.addEventListener("touchend", this._touchUp);
    },


    _down: function(e) {
      this._processEvent(e);

      // // Ignore these if we are currently gesturing
      // if (this._inGesture) {
      //   return;
      // }

      // this._inTouch = true;

      // We need to use our own instead of timeStamp so that we can run tests
      this._startTime = Date.now();

      this._startX = this._lastX = e.x;
      this._startY = this._lastY = e.y;

      if (this._options.start) {
        this._options.start(e);
      }
    },

    _gestureStart: function(e) {
      this._inGesture = true;

      // end the touch, trigger gesturestart
      if (this._options.end) {
        this._options.end(e);
        this._startTouchId = null;
      }

      this._calculateGestureXY(e);

      this._startTime = Date.now();

      this._startX = this._lastX = e.x;
      this._startY = this._lastY = e.y;


      this._startDistance = this._getGestureDistance(e);
      this._lastScale = 1;

      if (this._options.gestureStart) {
        this._options.gestureStart(e);
      }
    },

    _mouseMove: function(e) {
      this._calculateMouseXY(e);
      this._move(e);
    },

    _touchMove: function(e) {
      if (this._inGesture) {
        this._gestureChange(e);
      }
      else
      {
        this._calculateTouchXY(e);
        this._move(e);
      }
    },

    _move: function(e) {
      this._processEvent(e);

      this._lastX = e.x;
      this._lastY = e.y;

      if (this._options.move) {
        this._options.move(e);
      }
    },

    _gestureChange: function(e) {
      this._calculateGestureXY(e);

      this._processEvent(e);
      //this._processGesture(e);

      var newDistance = this._getGestureDistance(e);

      e.scale = newDistance / this._startDistance;
      e.scaleFromLast = e.scale - this._lastScale;

      this._lastX = e.x;
      this._lastY = e.y;
      this._lastScale = e.scale;

      if (this._options.gesture) {
        this._options.gesture(e);
      }
    },

    _mouseUp: function(e) {
      document.removeEventListener("mousemove", this._mouseMove);
      document.removeEventListener("mouseup", this._mouseUp);
      this._end(e);
    },

    _touchUp: function(e) {
      if (this._inGesture) {
        this._gestureEnd(e);
        return;
      }

      // Only end if we no longer have the starting touch
      if (this._containsTouch(e, this._startTouchId)) {
        return;
      }

      document.removeEventListener("touchmove", this._touchMove);
      document.removeEventListener("touchend", this._touchUp);

      this._end(e);
      this._startTouchId = null;
    },

    _end: function(e) {
      /*
        if e isn't set, end the handlers, call tap if it is within limits, call end
      */
      // if (!e) {
      //   this._endTouchHandlers();
      //   if (this._options.end) {
      //     this._options.end();
      //   }

      //   this._inTouch = false;

      //   return;
      // }

      // this._endTouchHandlers();
      this._processEvent(e);

      e.wasTap = false;

      var dist = Math.sqrt(((this._lastX - this._startX) * (this._lastX - this._startX)) + ((this._lastY - this._startY) * (this._lastY - this._startY)));

      if (dist < this._distCutoff && (Date.now() - this._startTime < this._timeCutoff)) {
        e.wasTap = true;
        if (this._options.tap) {
          this._options.tap(e);
        }
      }

      if (this._options.end) {
        this._options.end(e);
      }

      // this._inTouch = false;

      this._startX = null;
      this._startY = null;

      // Keep mouse events from being called
      // if (e) {
      e.preventDefault();
      e.stopImmediatePropagation();
      // }
    },

    _gestureEnd: function(e) {
      if (e.touches.length >= 2) {
        return;
      }

      this._inGesture = false;

      // No longer in a multi touch gesture
      if (this._options.gestureEnd) {
        this._options.gestureEnd(e);
      }

      document.removeEventListener("touchmove", this._touchMove);
      document.removeEventListener("touchend", this._touchUp);

    },

    // _gestureStart: function(e) {
    //   if (this._ignoreGestures) {
    //     return;
    //   }

    //   this._inGesture = true;

    //   if (this._inTouch) {
    //     console.log("we are in a touch");
    //     // We need to end the touch
    //     this._end();
    //   }



    //   this._processEvent(e);
    //   this._processGesture(e);

    //   this._startTime = e.timeStamp;

    //   this._startX = this._lastX = e.x;
    //   this._startY = this._lastY = e.y;

    // this._startScale = this._lastScale = e.scale;

    //   if (this._options.gestureStart) {
    //     this._options.gestureStart(e);
    //   }

    //   document.addEventListener("gesturechange", this._gestureChange);
    //   document.addEventListener("gestureend", this._gestureEnd);
    // },

    // _gestureChange: function(e) {
    //   this._processEvent(e);
    //   this._processGesture(e);

    //   this._lastX = e.x;
    //   this._lastY = e.y;
    //   this._lastScale = e.scale;

    //   if (this._options.gesture) {
    //     this._options.gesture(e);
    //   }
    // },

    // _gestureEnd: function(e) {
    //   this._processEvent(e);
    //   this._processGesture(e);

    //   if (this._options.gestureEnd) {
    //     this._options.gestureEnd(e);
    //   }

    //   document.removeEventListener("gesturechange", this._gestureChange);
    //   document.removeEventListener("gestureend", this._gestureEnd);

    //   this._inGesture = false;
    // },

    // Unregister the regular touch handlers, used for when gestures start

    // Given an e, add things like x and y regardless of touch or mouse
    _processEvent: function(e) {
      // var index = -1;
      // // It's a touch
      // if (e.touches && e.touches.length > 0 && (index = this._indexOfTouch(e, this._startTouchId)) !== -1) {
      //   e.x = e.touches[index].clientX;
      //   e.y = e.touches[index].clientY;
      // } else if (e.clientX) {
      //   // It's a click
      //   e.x = e.clientX;
      //   e.y = e.clientY;
      //   // } else if (e.pageX) {
      //   //   // gesture events only get a layerx
      //   //   e.x = e.pageX;
      //   //   e.y = e.pageY;
      // } else {
      //   // It's probably an end, there is no coords
      //   e.x = this._lastX;
      //   e.y = this._lastY;
      // }

      e.distFromLeft = e.x - this._offset.x;
      e.distFromTop = e.y - this._offset.y;

      e.xFromLast = e.x - this._lastX;
      e.yFromLast = e.y - this._lastY;

      e.distFromStartX = (this._startX !== null) ? e.x - this._startX : 0;
      e.distFromStartY = (this._startY !== null) ? e.y - this._startY : 0;
    },

    _getGestureDistance: function(e) {
      var xDist = (e.touches[0].clientX - e.touches[1].clientX);
      var yDist = (e.touches[0].clientY - e.touches[1].clientY);

      var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));
      return dist;
    },

    _containsTouch: function(e, identifier) {
      return this._indexOfTouch(e, this._startTouchId) !== -1;
    },

    _indexOfTouch: function(e, identifier) {
      var index = -1;
      if (e.touches && identifier !== null) {
        for (var i = 0; i < e.touches.length; i++) {
          if (e.touches[i].identifier == identifier) {
            index = i;
            break;
          }
        }
      }

      return index;
    },

    clear: function() {

      // hard code all these removes, might as well, this is only used in the test suite for now

      this._element.removeEventListener("mousedown", this._mouseDown);
      this._element.removeEventListener("touchstart", this._touchDown);
      // this._element.removeEventListener("gesturestart", this._gestureStart);

      document.removeEventListener("mousemove", this._mouseMove);
      document.removeEventListener("mouseup", this._mouseUp);

      document.removeEventListener("touchmove", this._touchMove);
      document.removeEventListener("touchend", this._touchUp);
    }


  };

  return TapHandler;
});
define('sections/login',["event", "section", "tapHandler", "online", "gauth", "data"], function(Event, Section, TapHandler, Online, GAuth, Data) {

  var Login = Section.extend({
    id: "login",

    _basicBox: null,
    _fileBox: null,

    _fileTitleElement: null,
    _userProfileElement: null,
    _fileOwnersElement: null,

    _button: null,

    init: function() {
      this._super();

      this._onlineStatusChanged = this._onlineStatusChanged.bind(this);
      this._basicBox = document.getElementById("login-basic");
      this._fileBox = document.getElementById("login-file");

      this._fileTitleElement = document.getElementById("login-file-title");
      this._userProfileElement = document.getElementById("login-owner-pic");
      this._fileOwnersElement = document.getElementById("login-file-owners");

      this._button = document.getElementById("loginbutton");
      new TapHandler(this._button, {tap: this._loginClicked.bind(this) });
    },

    show: function() {
      if (Online.isOnline()) {
        console.log("already online");
        this._turnOnline();
      }

      Event.addListener("onlineStatusChanged", this._onlineStatusChanged);
    },

    hide: function() {
      Event.removeListener("onlineStatusChanged", this._onlineStatusChanged);
    },

    _onlineStatusChanged: function(e) {
      this._turnOnline();
    },

    displayFileInfo: function(fileInfo) {
      this._basicBox.classList.add("hidden");

      this._waitAnimationEnd()
        .then((function() {
          var firstOwner = fileInfo.owners[0];

          this._fileTitleElement.textContent = fileInfo.title;
          this._fileOwnersElement.textContent = firstOwner.displayName;
          this._userProfileElement.src = firstOwner.picture.url

          this._fileBox.classList.remove("hidden");

        }).bind(this));
    },

    _turnOnline: function() {
      this._button.classList.remove("disabled");

      var hash = location.hash;
      if (hash.indexOf("#") === 0) {
        hash = hash.slice(1);

        Data.getRemoteFileInfo(hash)
        .then((function(fileInfo) {
          this.displayFileInfo(fileInfo);
        }).bind(this));
      }
    },

    _waitAnimationEnd: function() {
      return new Promise((function(resolve) {
        setTimeout(function() {
          resolve()
        }, 500);
      }).bind(this));
    },

    _loginClicked: function() {
      if (Online.isOnline()) {
        GAuth.authorizeWithPopup();
      }
    },
  });

  return Login;

});
define('platform',["class"], function(Class) {
  var Platform = Class.extend({
    // shortcut to body
    _b: null,

    standalone: null,

    transition: null,
    transitionEnd: null,
    animation: null,
    transform: null,
    transformOrigin: null,
    mouseWheel: null,

    init: function() {
      this._b = document.body;

      this.standalone = !! window.navigator.standalone;

      this.transition = this.addPrefix('transition');

      this.transitionEnd = {
        'transition': 'transitionend',
        'webkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionEnd',
        'OTransition': 'oTransitionEnd'
      }[this.transition];

      this.animation = this.addPrefix('animation');
      this.transform = this.addPrefix('transform');
      this.transformOrigin = this.addPrefix('transformOrigin');

      this.mouseWheel = typeof(window.onwheel) != "undefined" ? "wheel" : "mousewheel";

      window.requestAnimationFrame = window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        function(callback) {
          window.setTimeout(callback, 1000 / 60);
      };

      window.indexedDB = window.indexedDB ||
        window.webkitIndexedDB ||
        window.mozIndexedDB ||
        window.msIndexedDB ||
        window.oIndexedDB;
    },

    addPrefix: function(property) {
      var prefix = '';
      var vendor = ['ms', 'webkit', 'mox', 'o'];
      var style = this._b.style;

      if (typeof style[property] == 'string') {
        prefix = '';
      } else {
        for (var i = 0; i < vendor.length; i++) {
          if (typeof style['-' + vendor[i] + '-' + property] == 'string') {
            prefix = vendor[i];
            break;
          }
        }
      }

      var styleString = (prefix.length > 0) ? property.charAt(0).toUpperCase() + property.slice(1) : property;

      if (prefix) {
        return prefix + styleString;
      } else {
        return styleString;
      }
    }
  });

  var platform = new Platform();
  return platform;
});
define('sections/statusIndicator',["event", "section", "online", "platform"], function(Event, Section, Online, Platform) {

  var StatusIndicator = Section.extend({
    id: "mode",

    init: function() {
      this._super();
      this._onlineStatusChanged = this._onlineStatusChanged.bind(this);

      Event.addListener("onlineStatusChanged", this._onlineStatusChanged);

      if (!Online.isOnline()) {
        Online.waitToComeOnline(1500)
        .catch((function() {
          this._showOffline();
        }).bind(this));
      }
    },

    _onlineStatusChanged: function(e) {
      if (e.online) {
        this._showOnline();
      } else {
        // we are now offline, set the indicator
        this._showOffline();
      }
    },

    _showOnline: function() {
      this.element.classList.add("hidden");

      this._waitAnimationEnd()
        .then((function() {
          this.element.textContent = "Online";
          this.element.classList.remove("hidden");
          this.element.classList.remove("offline");
        }).bind(this));
    },

    _showOffline: function() {
      this.element.classList.add("hidden");

      this._waitAnimationEnd()
        .then((function() {
          this.element.textContent = "Offline";
          this.element.classList.remove("hidden");
          this.element.classList.add("offline");
        }).bind(this));

    },

    _waitAnimationEnd: function() {
      return new Promise((function(resolve) {
        setTimeout(function() {
          resolve()
        }, 500);
      }).bind(this));
    }
  });

  return StatusIndicator;

});
define('template',[], function() {

  function Template(templateId) {
    var script = document.getElementById("template-"+templateId);

    var element = document.createElement("div");
    element.innerHTML = script.innerHTML;
    return element.children[0];
  }

  return Template;

});
define('sections/fileItem',["section", "tapHandler", "event", "globals", "helpers", "platform", "template", "online", "gauth", "data"], function(Section, TapHandler, Event, g, Helpers, Platform, Template, Online, GAuth, Data) {

  var FileItem = Section.extend({
    _fileList: null,

    _thumbnailInfoElement: null,
    _fileNameElement: null,
    _thumbnailElement: null,

    _fileInfo: null,

    _slideMax: null,

    // sliding, scrolling, or null
    _slideState: null,

    init: function(fileList, fileInfo) {
      this._super();

      this._fileList = fileList;
      this._fileInfo = fileInfo;

      var ele = new Template("fileListItem");
      this.setElement(ele);

      this._thumbnailInfoElement = ele.getElementsByClassName("thumbnail-info")[0];
      this._fileNameElement = ele.getElementsByClassName("file-name")[0];
      this._thumbnailElement = ele.getElementsByClassName("thumbnail")[0];

      this._fileNameElement.textContent = fileInfo.name;
      this._thumbnailElement.src = fileInfo.thumbnail;

      new TapHandler(this.element, {
        tap: this._docTapped.bind(this),
        start: this._docStarted.bind(this),
        move: this._docMoved.bind(this),
        end: this._docEnded.bind(this)
      });

      if (g.isMobile()) {
        this._thumbnailElement.style[Platform.transform] = "translateX(0px);"
        this._thumbnailElement.translateX = 0;

        var deleteButton = ele.getElementsByClassName("delete")[0];
        window.a = deleteButton;
        // this._slideMax
      }
    },

    _docTapped: function(e) {
      var element = e.target;

      if (element.dataset.action) {
        var action = element.dataset.action;

        if (action == "delete") {
          // Delete was clicked
          return Data.deleteFile(this._fileInfo.id);
          // } else if (action == "share") {
          //   console.log(this._fileInfo);
          //   return;
        }
      } else if (Helpers.parentEleIsElement(element, this._thumbnailInfoElement)) {
        this._fileList.drawFile(this._fileInfo);
      }
    },

    _docStarted: function(e) {
      if (g.isMobile()) {
        this._slideState = null;

        var deleteButton = this._thumbnailInfoElement.getElementsByClassName("delete")[0];
        this._slideMax = -1 * deleteButton.offsetWidth;
      }
    },

    _docMoved: function(e) {
      if (g.isMobile()) {

        if (e.target != this._thumbnailElement) {
          return;
        }

        var dist = Math.sqrt(e.distFromStartX * e.distFromStartX + e.distFromStartY + e.distFromStartY);

        if (dist < 3) {
          e.preventDefault();
        } else if (this._slideState === null) {
          if (Math.abs(e.distFromStartX) > Math.abs(e.distFromStartY)) {
            this._slideState = "sliding";
          } else {
            this._slideState = "scrolling";
          }
        }

        if (this._slideState == "sliding") {

          var attemptedX = this._thumbnailElement.translateX + e.xFromLast;

          // sliding left means this will be negative

          var slide = Math.max(this._slideMax, Math.min(attemptedX, 0));

          this._thumbnailElement.style[Platform.transform] = "translateX(" + slide + "px)";
          this._thumbnailElement.translateX = slide;

          e.preventDefault();
        }
      }
    },

    _docEnded: function(e) {
      if (g.isMobile()) {
        this._slideState = null;

        this._thumbnailElement.classList.add("animating");
        // You have to slide half way to go all the way
        if (this._thumbnailElement.translateX < this._slideMax / 3) {

          this._thumbnailElement.style[Platform.transform] = "translateX(" + this._slideMax + "px)";
          this._thumbnailElement.translateX = this._slideMax;
        } else {
          this._thumbnailElement.style[Platform.transform] = "translateX(0px)";
          this._thumbnailElement.translateX = 0;
        }

        window.setTimeout((function() {
          this._thumbnailElement.classList.remove("animating");
        }).bind(this), 300);
        // console.log("ended", e);
      }
    },

    updateFileName: function(fileName) {
      this._fileNameElement.textContent = fileName;
    },

    updateThumbnail: function(thumbnail) {
      this._thumbnailElement.src = thumbnail;
    },
  });

  return FileItem;

});
define('sections/fileList',["section", "tapHandler", "event", "globals", "helpers", "online", "gauth", "sections/statusIndicator", "sections/fileItem", "data"], function(Section, TapHandler, Event, g, Helpers, Online, GAuth, StatusIndicator, FileItem, Data) {

  var FileList = Section.extend({
    id: "files-list-container",

    // The parent pane for this page
    _filesPane: null,

    // The element
    _fileListElement: null,

    _files: null,

    // The timer we use to schedule updates
    _updateTimeout: null,

    _indicator: null,

    _itemWidth: null,

    init: function(filesPane) {
      this._super();

      this._filesPane = filesPane;

      this._files = [];

      this._indicator = new StatusIndicator();

      this._fileListElement = document.getElementById("files-list");

      this._scheduleUpdate = this._scheduleUpdate.bind(this);
      this._onlineStatusChanged = this._onlineStatusChanged.bind(this);
      this._authenticatedStatusChanged = this._authenticatedStatusChanged.bind(this);

      Data.getFiles()
        .then((function(files) {
          for (var i = 0; i < files.length; i++) {
            var fileInfo = files[i];
            var fileTemplate = this._newFileWrapper(fileInfo);
            this._fileListElement.appendChild(fileTemplate);
          }

        }).bind(this));

      this.element.addEventListener("wheel", function(e) {
        e.stopPropagation();
      });

      new TapHandler(document.getElementById("create-file"), {
        tap: this._createTapped.bind(this)
      });

      Event.addListener("fileAdded", this._fileAdded.bind(this));
      Event.addListener("fileRemoved", this._fileRemoved.bind(this));
      Event.addListener("fileModified", this._fileModified.bind(this));
      Event.addListener("fileRenamed", this._fileRenamed.bind(this));
      Event.addListener("fileIdChanged", this._fileIdChanged.bind(this));
      Event.addListener("fileModifiedRemotely", this._fileModifiedRemotely.bind(this));
      Event.addListener("thumbnailUpdated", this._thumbnailUpdated.bind(this));
    },

    _newFileWrapper: function(fileInfo) {
      var fileItem = new FileItem(this, fileInfo);

      fileItem.element.fileInfo = fileInfo;

      this._files.push({
        fileInfo: fileInfo,
        fileItem: fileItem,
        element: fileItem.element,
      });

      return fileItem.element;
    },

    show: function() {
      console.log("Showing file list");
      Event.addListener("onlineStatusChanged", this._onlineStatusChanged);
      Event.addListener("authenticatedStatusChanged", this._authenticatedStatusChanged);

      // This could happen if we are online and then navigate to this page
      if (Online.isOnline()) {
        Data.checkForUpdates()
          .then((function() {
            this._scheduleUpdate()
          }).bind(this));
      }
    },

    hide: function() {
      console.log("hiding file list");
      Event.removeListener("onlineStatusChanged", this._onlineStatusChanged);
      Event.removeListener("authenticatedStatusChanged", this._authenticatedStatusChanged);

      if (this._updateTimeout) {
        clearTimeout(this._updateTimeout);
      }
    },

    _scheduleUpdate: function() {
      if (this._updateTimeout) {
        clearTimeout(this._updateTimeout);
      }

      this._updateTimeout = setTimeout((function() {
        if (!this._visible || !Online.isOnline()) {
          return;
        }

        Data.checkForUpdates().then((function() {
          this._scheduleUpdate()
        }).bind(this));
      }).bind(this), 15 * 1000);
    },

    drawFile: function(fileInfo) {
      this._filesPane.setPane("draw", fileInfo);
    },

    _createTapped: function(e) {
      return Data.createFile()
        .then(function(file) {
          return file.fileInfoPromise;
        })
        .then((function(fileInfo) {
          console.log("Showing draw for", fileInfo);
          this._filesPane.setPane("draw", fileInfo);
        }).bind(this));
    },

    // EVENTS
    _onlineStatusChanged: function(e) {
      // check for updates if we come online while looking at this page
      if (e.online && GAuth.isAuthenticated()) {
        Data.checkForUpdates()
          .then((function() {
            this._scheduleUpdate()
          }).bind(this))
          .
        catch (function(error) {
          console.error(error, error.stack, error.message);
        });
      }
    },

    _authenticatedStatusChanged: function(e) {
      if (e.authenticated) {
        Data.checkForUpdates()
          .then((function() {
            this._scheduleUpdate()
          }).bind(this))
          .
        catch (function(error) {
          console.error(error, error.stack, error.message);
        });
      }
    },

    _fileAdded: function(fileInfo) {
      var fileTemplate = this._newFileWrapper(fileInfo);

      this._fileListElement.insertBefore(fileTemplate, this._fileListElement.children[1]);
    },

    _fileRemoved: function(fileId) {
      for (var i in this._files) {
        var file = this._files[i];
        if (file.fileInfo.id == fileId) {
          this._fileListElement.removeChild(file.element);
          delete this._files[i];
          return;
        }
      }
    },

    _fileModified: function(fileInfo) {
      for (var i in this._files) {
        var file = this._files[i];
        if (file.fileInfo.id == fileInfo.id) {
          file.fileInfo.modifiedTime = fileInfo.modifiedTime;

          this._fileListElement.removeChild(file.element);
          this._fileListElement.insertBefore(file.element, this._fileListElement.children[1]);
          return;
        }
      }
    },

    _fileRenamed: function(fileInfo) {
      for (var i in this._files) {
        var file = this._files[i];
        if (file.fileInfo.id == fileInfo.id) {
          file.fileItem.updateFileName(fileInfo.name);
          file.fileInfo.name = fileInfo.name;
          return;
        }
      }
    },

    _fileIdChanged: function(e) {
      for (var i in this._files) {
        var file = this._files[i];
        if (file.fileInfo.id == e.oldId) {
          file.fileInfo.id = e.newId;
          break;
        }
      }
    },

    _fileModifiedRemotely: function(fileInfo) {

    },

    _thumbnailUpdated: function(fileInfo) {
      for (var i in this._files) {
        var file = this._files[i];
        if (file.fileInfo.id == fileInfo.id) {
          file.fileItem.updateThumbnail(fileInfo.thumbnail);
          file.fileInfo.thumbnail = fileInfo.thumbnail;
          return;
        }
      }
    },
  });

  return FileList;

});
define('sections/draw',["section", "globals", "event", "helpers", "tapHandler", "platform", "db", "bezierCurve", "data", "online", "components/manipulateCanvas"], function(Section, g, Event, Helpers, TapHandler, Platform, db, BezierCurve, Data, Online, ManipulateCanvas) {

  var Draw = Section.extend({
    id: "draw",

    // The parent pane for this page
    _filesPane: null,

    // Instance of draw canvas that is handling all the drawing
    _manipulateCanvas: null,

    // The actual canvas element
    _canvas: null,

    // The file we are currently rendering
    _file: null,

    // Local settings such as offset and zoom
    _settings: null,

    // If we are currently doing something like drawing, it will be here
    _currentAction: null,

    // If we need to redraw but shouldn't re-render anything
    _update: false,

    // Do we need to update on this frame?
    _updateAll: true,

    // Does the current action need to be redrawn?
    _updateCurrentAction: false,

    // Set this to false to stop the render loop
    _shouldRender: false,

    // Timeout for saving settings
    _saveSettingsTimeout: null,

    // Timeout for when we stopped scrolling
    _mouseWheelTimeout: null,

    // The timer we use to schedule file sync
    _fileSyncTimeout: null,

    // The tap handler for the draw pane. Needed to turn on and off gestures
    _canvasTapHandler: null,

    _toolTapHandler: null,

    _fileNameElement: null,

    // The overlay of modals
    _overlay: null,

    init: function(filesPane) {
      this._super();

      this._filesPane = filesPane;

      this._canvas = document.getElementById('canvas');

      this._actionsAdded = this._actionsAdded.bind(this);
      this._actionsRemoved = this._actionsRemoved.bind(this);
      this._resize = this._resize.bind(this);
      this._fileModifiedRemotely = this._fileModifiedRemotely.bind(this);
      this._fileRenamed = this._fileRenamed.bind(this);
      this._redraw = this._redraw.bind(this);
      this._onlineStatusChanged = this._onlineStatusChanged.bind(this);
      this._scheduleMouseWheelTimeout = this._scheduleMouseWheelTimeout.bind(this);

      // Keep the trackpad from trigger chrome's back event
      this.element.addEventListener("touchmove", function(e) {
        e.preventDefault();
      });

      this._canvasTapHandler = new TapHandler(this.element, {
        start: this._start.bind(this),
        move: this._move.bind(this),
        end: this._end.bind(this),
        gesture: this._gesture.bind(this),
        gestureStart: this._gestureStart.bind(this),
        gestureEnd: this._gestureEnd.bind(this)
      });


      this._toolTapHandler = new TapHandler(document.getElementById("tools"), {
        tap: this._toolChanged.bind(this),
        start: this._toolStart.bind(this),
        end: this._toolEnd.bind(this)
      });

      new TapHandler(document.getElementById("menu"), {
        start: function(e) {
          e.stopPropagation();
        },
        tap: this._menuTapped.bind(this),
      });

      new TapHandler(document.getElementById("fileName"), {
        start: function(e) {
          e.stopPropagation();
        }
      });

      // new TapHandler(document.getElementById("options"), {
      //   start: function(e) {
      //     e.stopPropagation();
      //   },
      //   tap: this._menuTapped.bind(this),
      // });

      new TapHandler(document.getElementById("colorPicker"), {
        start: function(e) {
          e.stopPropagation();
        },
        tap: this._colorPicked.bind(this)
      });

      this._overlay = document.getElementById("draw-overlay");
      this._overlay.addEventListener("mousedown", this._hideModal.bind(this));
      this._overlay.addEventListener("touchstart", this._hideModal.bind(this));


      this.element.addEventListener(Platform.mouseWheel, this._mouseWheel.bind(this));
      this.element.addEventListener("keydown", this._keyDown.bind(this));

      this._fileNameElement = document.getElementById("fileName");
      this._fileNameElement.addEventListener("keydown", this._fileNameKeyDown.bind(this));
      this._fileNameElement.addEventListener("blur", this._fileNameBlur.bind(this));

    },

    show: function(fileInfo) {
      return this._tryLoadFile(fileInfo)
        .catch ((function() {
        // error loading the file, set a timeout for waiting to come online
        return Online.waitToComeOnline(10000)
          .then((function() {
            return Data.loadFileFromRemote(fileInfo.id)
          }).bind(this))
          .then((function(fileInfo) {
            return this._tryLoadFile(fileInfo);
          }).bind(this))

        .
        catch ((function(error) {
          console.error("Unable to draw for this file", error);
          location.hash = "";
          this._filesPane.setPane("list");
          return;
        }).bind(this));
      }).bind(this))
    },

    _tryLoadFile: function(fileInfo) {
      return Data.loadFile(fileInfo.id)
        .then((function(file) {

          this._file = file;

          file.listen(this._actionsAdded, this._actionsRemoved);

          file.fileInfoPromise.then((function(fileInfo) {
            this._fileNameElement.value = fileInfo.name;
          }).bind(this));

          file.localSettings().then((function(settings) {
            this._settings = settings;
            document.getElementById("chosenColorSwatch").style.backgroundColor = this._settings.color;

            this._setActiveTool();
            this._manipulateCanvas = new ManipulateCanvas(this._canvas, this._settings);

            this._redraw();

            // Keep this file in sync
            this._scheduleUpdate();
          }).bind(this));

          this._updateAll = true;
          this._shouldRender = true;

          Event.addListener("fileModifiedRemotely", this._fileModifiedRemotely);
          Event.addListener("fileRenamed", this._fileRenamed);
          Event.addListener("onlineStatusChanged", this._onlineStatusChanged);

          this._resize();

          // Focus on the canvas after we navigate to it
          setTimeout(function() {
            this._canvas.focus();
          }.bind(this), 400);

          window.addEventListener("resize", this._resize);
        }).bind(this))
    },

    hide: function() {
      // If we are never showing this pane, then skip cleaning
      if (this._file) {
        this._file.stopListening();

        // Close the file after we have left, keep it from stuttering.
        window.setTimeout((function() {
          this._file.updateThumbnail()
            .then((function(file) {
              return Data.close(file);
            }).bind(this, this._file))
            .
          catch (function(error) {
            console.error(error, error.stack, error.message);
          });
        }).bind(this), 600);
      }

      this._shouldRender = false;

      Event.removeListener("fileModifiedRemotely", this._fileModifiedRemotely);
      Event.removeListener("fileRenamed", this._fileRenamed);
      Event.removeListener("onlineStatusChanged", this._onlineStatusChanged);
      window.removeEventListener("resize", this._resize);
    },

    _actionsAdded: function(e) {
      if (e.isLocal) {
        this._update = true;
        this._manipulateCanvas.addAction(e.items[0]);
      } else {
        this._updateAll = true;
      }
    },

    _actionsRemoved: function(e) {
      this._updateAll = true;
    },

    _resize: function() {
      this._canvas.width = window.innerWidth;
      this._canvas.height = window.innerHeight;

      this._updateAll = true;
    },

    _zoom: function(x, y, dScale) {
      if (this._manipulateCanvas.zoom(x, y, dScale)) {
        this._saveSettings();
        this._updateAll = true;
      }
    },

    _pan: function(dx, dy) {
      if (this._manipulateCanvas.pan(dx, dy)) {
        this._saveSettings();
        this._updateAll = true;
      }
    },

    _mouseWheel: function(e) {
      //console.log(e);
      // deltaX is chrome, wheelDelta is safari
      var dx = !isNaN(e.deltaX) ? -e.deltaX : (e.wheelDeltaX / 5);
      var dy = !isNaN(e.deltaY) ? -e.deltaY : (e.wheelDeltaY / 5);

      this._manipulateCanvas.useCurves(false);

      this._scheduleMouseWheelTimeout();

      if (this._settings.tools.scroll == "pan") {
        this._pan(dx, dy);
      } else if (this._settings.tools.scroll == "zoom") {
        if (dy != 0) {
          this._zoom(e.clientX, e.clientY, dy / 100.0 * this._settings.scale);
        }
      }
    },

    _scheduleMouseWheelTimeout: function() {
      if (this._mouseWheelTimeout) {
        clearTimeout(this._mouseWheelTimeout);
      }

      this._mouseWheelTimeout = setTimeout((function() {
        this._manipulateCanvas.useCurves(true);
        this._updateAll = true;
      }).bind(this), 100);
    },

    _start: function(e) {
      var tool = this._settings.tools.gesture || this._settings.tools.point;
      if (e.button == 1) { // middle mouse
        tool = "pan";
      }

      if (tool == "pan") {
        this._manipulateCanvas.useCurves(false);
        return;
      }

      var world = Helpers.screenToWorld(this._settings, e.distFromLeft, e.distFromTop);

      if (this._currentAction) {
        console.error("Current action isn't null!");
      }

      this._currentAction = {
        type: "stroke",
        value: {
          points: [
            [world.x, world.y]
          ],
          width: 2,
          lockWidth: true, // should the width stay the same regardless of zoom
          color: this._settings.color
        }
      }

      if (tool == "eraser") {
        this._currentAction.value.width = 30 / this._settings.scale;
        this._currentAction.value.color = "#ffffff";
        this._currentAction.value.lockWidth = false;
      } else if (this._settings.tools.point == "pencil") {

      }
    },

    _move: function(e) {
      var tool = this._settings.tools.gesture || this._settings.tools.point;

      if (e.button == 1) { // middle mouse
        tool = "pan";
      }

      if (tool == "pan") {
        this._pan(e.xFromLast, e.yFromLast);
      } else if (tool == "pencil" || tool == "eraser") {

        if (!this._currentAction) {
          // no current action. This can happen if we were dragging a tool and let up the
          // tool button and kept dragging
          return;
        }

        var world = Helpers.screenToWorld(this._settings, e.distFromLeft, e.distFromTop);

        var currentStroke = this._currentAction.value;

        var points = currentStroke.points;
        var lastPoint = points[points.length - 1];


        var dist = Math.sqrt(
          ((lastPoint[0] - world[0]) * (lastPoint[0] - world[0])) +
          ((lastPoint[1] - world[1]) * (lastPoint[1] - world[1]))
        );

        if (dist < 0.001) {
          return;
        }

        currentStroke.points.push([world.x, world.y]);
        this._updateCurrentAction = true;
      }
    },

    _end: function(e) {
      var tool = this._settings.tools.gesture || this._settings.tools.point;

      if (tool == "pan") {
        this._manipulateCanvas.useCurves(true);
        this._updateAll = true;
      } else if (tool == "pencil" || tool == "eraser") {
        if (!this._currentAction) {
          // no current action. This can happen if we were dragging a tool and let up the
          // tool button and kept dragging
          return;
        }

        var currentAction = this._currentAction;
        this._currentAction = null;

        var currentStroke = currentAction.value;

        if (currentStroke.points.length < 2) {
          // two options, don't count the stroke
          return;

          // or render a point
        }

        // Copy the control points out now that we are done with it.
        var controlPoints = Helpers.cloneArray(BezierCurve.getCurveControlPoints(currentStroke.points));

        currentStroke.controlPoints = controlPoints;

        this._updateCurrentAction = true;

        // the actions is done, we should redraw everything.
        this._updateAll = true;

        this._saveAction(currentAction);
      }
    },

    _saveAction: function(action) {
      // We aren't going to send these to drive
      // delete action.value.controlPoints;
      action.id = Helpers.getGuid();
      this._file.addAction(action)
        .
      catch (function(e) {
        console.error(e, e.stack, e.message);
      });
    },

    _gesture: function(e) {
      this._pan(e.xFromLast, e.yFromLast);
      this._zoom(e.x, e.y, e.scaleFromLast * this._settings.scale);
    },

    _gestureStart: function() {
      this._manipulateCanvas.useCurves(false);
    },

    _gestureEnd: function() {
      this._manipulateCanvas.useCurves(true);
      this._updateAll = true;
    },

    _redraw: function() {
      // If we shouldn't render, exit the loop
      if (!this._shouldRender) {
        return;
      }

      if (this._updateAll) {
        var actions = this._file.getActions();
        this._manipulateCanvas.doAll(actions);
      }

      if (this._updateCurrentAction && this._currentAction) {
        var currentAction = this._currentAction;
        var controlPoints = BezierCurve.getCurveControlPoints(currentAction.value.points);

        currentAction.value.controlPoints = controlPoints;
        this._manipulateCanvas.doTemporaryAction(currentAction)
      }

      if (this._updateAll || this._updateCurrentAction || this._update) {
        this._manipulateCanvas.render();

        this._update = false;
        this._updateAll = false;
        this._updateCurrentAction = false;
      }

      requestAnimationFrame(this._redraw);
    },

    _menuTapped: function(e) {
      if (e.target.tagName == "LI") {
        var action = e.target.dataset.action;

        if (action == "back") {
          this._file.fileInfoPromise.then((function(fileInfo) {
            this._filesPane.setPane("list", fileInfo);
          }).bind(this));
        } else if (action == "rename") {
          e.target.focus();
        }
        // else if (action == "export") {
        //   var dataURL = this._canvas.toDataURL();
        //   window.open(dataURL);
        // }
      }
    },

    _showModal: function(modalId) {
      var modal = document.getElementById(modalId);
      if (!modal) {
        console.error("No modal with that id");
        return;
      }

      this._overlay.currentModal = modalId;
      this._overlay.style.visibility = "visible";

      setTimeout(function() {
        modal.classList.add("visible");
      }, 0);
    },

    _hideModal: function(e) {
      if (e && e.target != this._overlay) {
        // overlay was explicitly tapped
        return;
      }

      if (this._overlay.currentModal) {
        // A modal is showing
        var modal = document.getElementById(this._overlay.currentModal);
        if (modal.dataset.closeable && modal.dataset.closeable === "false") {
          // If the modal doesn't allow itself to be closed, just skip
          if (e) {
            e.stopPropagation();
          }

          return;
        }

        modal.classList.remove("visible");
        this._overlay.currentModal = "";
      }

      this._overlay.style.visibility = "hidden";

      if (e) {
        //e.stopPropagation();
      }
    },

    _colorPicked: function(e) {
      var parent = Helpers.parentEleWithClassname(e.target, "swatch");
      if (parent) {
        var color = parent.style.backgroundColor;
        this._settings.color = color;
        this._saveSettings();

        document.getElementById("chosenColorSwatch").style.backgroundColor = color;
        this._hideModal();
      }

      e.stopPropagation();
    },

    _toolStart: function(e) {

      var tool = e.target.dataset.tool;
      var action = e.target.dataset.action;

      if (e.target.tagName == "LI" && tool) {
        if (tool == "pan" || tool == "eraser" || tool == "pencil") {
          this._settings.tools.gesture = tool;

          this._setActiveTool();

          this._canvasTapHandler.ignoreGestures(true);
          this._toolTapHandler.ignoreGestures(true);
        }
      }

      e.stopPropagation();
      e.preventDefault();
    },

    _toolEnd: function(e) {
      if (e) {
        var tool = e.target.dataset.tool;

        if (e.target.tagName == "LI" && tool) {
          if (tool == "pan" || tool == "eraser" || tool == "pencil") {
            this._settings.tools.gesture = null;

            this._setActiveTool();

            this._canvasTapHandler.ignoreGestures(false);
            this._toolTapHandler.ignoreGestures(false);
          }
        }
      }
    },

    _toolChanged: function(e) {
      var parent = Helpers.parentEleWithClassname(e.target, "toolitem");

      if (parent && parent.tagName == "LI") {
        var action = parent.dataset.action;
        var tool = parent.dataset.tool;

        if (tool) {
          if (tool == "pencil") {
            this._settings.tools.point = "pencil";
          } else if (tool == "eraser") {
            this._settings.tools.point = "eraser";
          } else if (tool == "pan") {
            // TODO: this should probably check if the event was a touch
            // or mouse event
            if (g.isComputer()) {
              this._settings.tools.scroll = "pan";
            } else {
              this._settings.tools.point = "pan";
            }
          } else if (tool == "zoom") {
            this._settings.tools.scroll = "zoom";
          }

          this._setActiveTool();
          this._saveSettings();
        } else if (action) {
          if (action == "undo") {
            this._undo();
          } else if (action == "redo") {
            this._redo();
          }
          if (action == "color") {
            this._showModal("colorPicker");

            e.preventDefault();
            e.stopImmediatePropagation();
          }
        }
      }
    },

    _setActiveTool: function() {
      var toolsElement = document.getElementById("tools");

      function addRemove(type) {
        var prevTool = toolsElement.dataset["active" + type];
        if (prevTool) {
          var toolItem = document.getElementById(prevTool);
          toolItem.classList.remove("active-" + type);
        }

        var currentTool = this._settings.tools[type];

        if (currentTool) {

          var currentToolId = currentTool + "-tool";
          var newToolItem = document.getElementById(currentToolId);
          newToolItem.classList.add("active-" + type);

          toolsElement.dataset["active" + type] = currentToolId;
        } else {
          delete toolsElement.dataset["active" + type];
        }

      }

      addRemove = addRemove.bind(this);

      addRemove("point");

      if (g.isComputer()) {
        addRemove("scroll");
      }
    },

    _keyDown: function(e) {
      var key = String.fromCharCode(e.keyCode);

      if (
        ((g.isMac() && e.metaKey && e.shiftKey) && key == "Z") ||
        ((g.isPC() && e.ctrlKey) && key == "Y")) {
        // Redo

        this._redo();
      } else if ((
          (g.isMac() && e.metaKey) ||
          (g.isPC() && e.ctrlKey)
        ) &&
        key == "Z") {
        // Undo

        e.preventDefault();
        this._undo();
      } else if (key == "Z") {
        this._settings.tools.scroll = "zoom";
        this._setActiveTool();
      } else if (key == "P") {
        this._settings.tools.scroll = "pan";
        this._setActiveTool();
      }

    },

    _undo: function() {
      this._file.undo();
      this._updateAll = true;

    },

    _redo: function() {
      this._file.redo();
      this._updateAll = true;
    },

    _fileNameKeyDown: function(e) {
      if (e.keyCode == 13) { // Enter
        this._fileNameElement.blur();
      }
    },

    _fileNameBlur: function(e) {
      var name = e.target.value;
      this._file.rename(name);
    },


    _saveSettings: function() {
      // If the timeout is set already
      if (this._saveSettingsTimeout) {

        // Clear it and set a new one
        clearTimeout(this._saveSettingsTimeout);
      }

      this._saveSettingsTimeout = setTimeout((function() {
        this._file.localSettings(this._settings);
      }).bind(this), 100);

    },

    _fileModifiedRemotely: function(fileInfo) {
      this._file.fileInfoPromise.then((function(file) {
        if (fileInfo.id == file.id) {
          this._updateAll = true;
        }
      }).bind(this));
    },

    _fileRenamed: function(file) {
      this._file.fileInfoPromise.then((function(fileInfo) {
        if (fileInfo.id == file.id) {
          this._fileNameElement.value = file.name;
        }
      }).bind(this));
    },

    _onlineStatusChanged: function(status) {
      // check for updates if we come online while looking at this page
      // Make sure we sync actions in this case
      if (status.online && this._file.isConnected()) {
        this._file.sync(null, true)
          .then((function() {
            this._scheduleUpdate()
          }).bind(this))
          .
        catch (function(error) {
          console.error(error, error.stack, error.message);
        });
      }
    },

    _scheduleUpdate: function() {
      if (this._fileSyncTimeout) {
        clearTimeout(this._fileSyncTimeout);
      }

      this._fileSyncTimeout = setTimeout((function() {
        if (!this._visible) {
          return;
        }

        if (this._currentAction) {
          console.log("We are currently drawing, delaying sync");
          this._scheduleUpdate();
          return;
        }

        // If we haven't yet finished loading the file, skip the sync for now
        if (this._file.isConnected()) {
          this._file.sync(null, false).then((function() {
            this._scheduleUpdate()
          }).bind(this));
        } else {
          this._scheduleUpdate();
        }

      }).bind(this), 15 * 1000);
    },
  });

  return Draw;

});
define('managers/files',["section", "event", "platform", "data", "sections/fileList", "sections/draw"], function(Section, Event, Platform, Data, FileList, Draw) {

  var Files = Section.extend({
    id: "files",

    _paneWrapper: null,

    _screenWidth: 0,

    panes: null,

    currentPaneName: null,

    _currentState: null,

    init: function() {
      this._super();

      this._screenWidth = window.innerWidth;

      this._paneWrapper = document.getElementById("files-pane-wrapper");

      this._windowResized = this._windowResized.bind(this);
      this._finishedSliding = this._finishedSliding.bind(this);

      this._paneWrapper.addEventListener(Platform.transitionEnd, this._finishedSliding);

      this.panes = {};

      this.panes.list = {
        offsetX: 0,
        pane: new FileList(this)
      };

      this.panes.draw = {
        offsetX: this._screenWidth,
        pane: new Draw(this)
      };

      this.panes.draw.pane.element.style[Platform.transform] = 'translate(' + this._screenWidth + "px, 0px)";

      this._currentState = {
        pane: "list",
        details: null
      };

      if (localStorage.filesPane) {
        this._currentState = JSON.parse(localStorage.filesPane);
      }

      var hash = location.hash;
      if (hash.indexOf("#") === 0) {
        // We have a hash, can we open this file?
        hash = hash.slice(1);

        this._currentState.pane = "draw";
        this._currentState.details = {
          id: hash
        };
      }

      Event.addListener("fileIdChanged", this._fileIdChanged.bind(this));
    },

    show: function() {
      this.setPane(this._currentState.pane, this._currentState.details);
      this._redoOffsets();

      window.addEventListener("resize", this._windowResized);
    },

    hide: function() {
      window.removeEventListener("resize", this._windowResized);
    },

    setPane: function(pane, details) {
      if (this.currentPaneName == pane)
        return;

      var paneobj = null;

      if (this.currentPaneName) {

        var paneobj = this.panes[this.currentPaneName].pane;

        if (paneobj.hide) {
          paneobj.hide();
        }

        paneobj.afterHide();
      }


      paneobj = this.panes[pane].pane;

      if (paneobj.show) {
        paneobj.show(details);
      }

      paneobj.afterShow();

      this.currentPaneName = pane;


      // Finish up
      var totalPane = this.panes[pane];

      var translate = "translate(" + (-1 * totalPane.offsetX) + "px, 0px)";
      if (this._paneWrapper.style[Platform.transform] != translate) {
        this._paneWrapper.classList.add("ani4");
        this._paneWrapper.style[Platform.transform] = translate;
      }


      this._currentState = {
        pane: "list",
        details: null
      };

      if (pane != "list") {
        this._currentState.pane = pane;
        this._currentState.details = details;
      }

      localStorage.filesPane = JSON.stringify(this._currentState);
    },

    _finishedSliding: function(e) {
      if (e.target != this._paneWrapper) {
        return;
      }

      // Remove the animation
      this._paneWrapper.classList.remove("ani4");

      this._redoOffsets();
    },

    _windowResized: function() {
      this._redoOffsets();
    },

    _redoOffsets: function() {
      this._screenWidth = window.innerWidth;

      // Set the offsets on all the panes so that the current pane is 0,0
      var currentIndex = 0;
      for (var pane in this.panes) {
        if (this.currentPaneName == pane) {
          break;
        }

        currentIndex++;

      }

      var startX = -1 * currentIndex * this._screenWidth;
      for (var pane in this.panes) {
        this.panes[pane].offsetX = startX;
        this.panes[pane].pane.element.style[Platform.transform] = 'translate(' + startX + "px, 0px)";
        startX += this._screenWidth;
      }

      this._paneWrapper.style[Platform.transform] = "";
    },

    _fileIdChanged: function(e) {
      // the current state details is a reference, so the id will change out from under us
      // if it is the new id, then save it
      if (this._currentState.details && this._currentState.details.id == e.newId) {
        localStorage.filesPane = JSON.stringify(this._currentState);
      }
    },
  });

  return Files;

});
define('sections/main',["section", "event", "managers/files"], function(Section, Event, Files) {

  var Main = Section.extend({
    id: "main-container",

    mainContent: null,

    // The panes we slide between in the main-content
    panes: null,
    currentPane: "",


    init: function() {
      this._super();

      this.mainContent = document.getElementById("main-content");
      this.panes = {};

      this.panes.files = new Files();
      
      Event.addListener("logout", this._logout.bind(this));
    },

    show: function() {
      if (localStorage.currentPane) {
        this.setPane(localStorage.currentPane);
      } else {
        this.setPane("files");
      }
    },


    setPane: function(pane) {
      if (this.currentPane == pane)
        return;

      var paneobj = null;

      if (this.currentPane) {

        var paneobj = this.panes[this.currentPane];

        if (paneobj.hide) {
          paneobj.hide();
        }

        paneobj.afterHide();
      }

      paneobj = this.panes[pane];

      if (paneobj.show) {
        paneobj.show();
      }

      paneobj.afterShow();

      this.currentPane = pane;

      localStorage.currentPane = pane;
      Event.trigger("paneChanged", {
        pane: paneobj
      });
    },

    _logout: function() {
      delete localStorage.currentPane;
    }
  });

  return Main;

});
define('managers/login',["event", "gauth", "sections/login", "sections/main"], function(Event, GAuth, LoginSection, MainSection) {
  function LoginManager() {
    this.init();
  }

  LoginManager.prototype = {
    pages: null,
    currentPage: "",

    init: function() {
      this.pages = {};

      Event.addListener("authenticatedStatusChanged", this._authenticatedStatusChanged.bind(this));

      this.pages.login = new LoginSection();
      this.pages.main = new MainSection();

      if (localStorage.loggedIn) {
        this.setPage("main");
      }
      else
      {
        this.setPage("login");
      }
    },

    setPage: function(page) {
      var pageobj = null;

      if (this.currentPage) {

        pageobj = this.pages[this.currentPage];

        if (pageobj.hide) {
          pageobj.hide();
        }
        pageobj.afterHide();
      }

      pageobj = this.pages[page];

      if (pageobj.show) {
        pageobj.show();
      }
      pageobj.afterShow();

      this.currentPage = page;
    },

    _authenticatedStatusChanged: function(status) {
      if (status.authenticated) {
        localStorage.loggedIn = true;
        this.setPage("main");
      }
      else
      {
        localStorage.loggedIn = false;
        this.setPage("login");
      }
    },
  };

  return LoginManager;
});
define('sections/updateMessage',["event", "section", "tapHandler"], function(Event, Section, TapHandler) {

  var UpdateMessage = Section.extend({
    id: "updateBar",

    init: function() {
      this._super();

      var button = document.getElementById("updateBarContent");
      new TapHandler(button, {tap: this._buttonClicked.bind(this) });
    },

    show: function() {
      this.element.classList.add("visible");
    },

    hide: function() {
      this.element.classList.remove("visible");
    },

    _buttonClicked: function() {
      location.reload();
    }
  });

  return new UpdateMessage();

});
define('cacheHandler',["sections/updateMessage"], function(UpdateMessage) {

  function CacheHandler() {
    this.init();
  }

  CacheHandler.prototype = {
    init: function() {
    },

    updateReady: function() {
      UpdateMessage.show();
    }
  }

  return new CacheHandler(); 
});
function init() {
  window.log = console.log.bind(console);

  // This prevents the browser from going back / forwards while panning in draw
  window.addEventListener("wheel", function(e) {
    e.preventDefault();
  });


  require(["promise", "event", "globals", "helpers", "migrate", "managers/login", "gauth"], function(Promise, Event, g, Helpers, Migrate, LoginManager, GAuth) {
    Migrate.run()
      .then((function() {
        g.setHTMLDevices();

        var loginManager = new LoginManager();
      }).bind(this));

    window.addEventListener("resize", function() {
      // make sure we are scrolled to 0. Without this there are problems
      // when changing device orientation
      window.scroll(0, 0);
      setHeight();
    });

    function setHeight() {
      document.body.style.height = window.innerHeight + "px";
    }

    setHeight();
  });
}

if (document.readyState === "interactive" || document.readyState === "complete") {
  init();
} else {
  document.addEventListener("DOMContentLoaded", init, false);
}


if (!window.Promise) {
  require(["promise"], function(Promise) {
    window.Promise = Promise;
  });
}

window.gapiLoaded = function() {
  require(["online"], function(Online) {
    Online.gapiLoaded();
  });
}

window.gapiLoadError = function() {
  require(["online"], function(Online) {
    Online.gapiLoadError();
  });
}

window.applicationCache.addEventListener("updateready", function() {
  require(["cacheHandler"], function(CacheHandler) {
    CacheHandler.updateReady();
  });
});
define("main", function(){});
}());
//# sourceMappingURL=main.min.js.map